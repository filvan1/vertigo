{"version":3,"file":"core.modern.js","sources":["../src/constants.ts","../src/utils/bounds.ts","../src/utils/buffer-utils.ts","../src/utils/color-utils.ts","../src/utils/file-utils.ts","../src/utils/image-utils.ts","../src/utils/is-plain-object.ts","../src/utils/logger.ts","../src/utils/math-utils.ts","../src/utils/property-utils.ts","../src/utils/uuid.ts","../src/utils/http-utils.ts","../src/properties/property.ts","../src/properties/extensible-property.ts","../src/properties/accessor.ts","../src/properties/animation.ts","../src/properties/animation-channel.ts","../src/properties/animation-sampler.ts","../src/properties/buffer.ts","../src/properties/camera.ts","../src/properties/extension-property.ts","../src/properties/texture-info.ts","../src/properties/material.ts","../src/properties/mesh.ts","../src/properties/node.ts","../src/properties/primitive.ts","../src/properties/primitive-target.ts","../src/properties/scene.ts","../src/properties/skin.ts","../src/properties/texture.ts","../src/properties/root.ts","../src/document.ts","../src/extension.ts","../src/io/reader-context.ts","../src/io/reader.ts","../src/io/writer-context.ts","../src/io/writer.ts","../src/io/platform-io.ts","../src/io/node-io.ts","../src/io/deno-io.ts","../src/io/web-io.ts"],"sourcesContent":["// Injected at compile time, from $npm_package_version.\ndeclare const PACKAGE_VERSION: string;\n\n/**\n * Current version of the package.\n * @hidden\n */\nexport const VERSION = `v${PACKAGE_VERSION}`;\n\n/** @internal */\nexport const NAME = '@gltf-transform/core';\n\n/**\n * Interface allowing Accessor setter/getter methods to be used interchangeably with gl-matrix\n * arrays or with three.js math objects' fromArray/toArray methods. For example, THREE.Vector2,\n * THREE.Vector3, THREE.Vector4, THREE.Quaternion, THREE.Matrix3, THREE.Matrix4, and THREE.Color.\n *\n * @internal\n */\nexport interface ArrayProxy {\n\t/** Sets the value of the object from an array of values. */\n\tfromArray(array: number[]): ArrayProxy;\n\t/** Writes the value of the object into the given array. */\n\ttoArray(array: number[]): number[];\n}\n\n/**\n * TypeScript utility for nullable types.\n * @hidden\n */\nexport type Nullable<T> = { [P in keyof T]: T[P] | null };\n\n/**\n * 2-dimensional vector.\n * @hidden\n */\nexport type vec2 = [number, number];\n\n/**\n * 3-dimensional vector.\n * @hidden\n */\nexport type vec3 = [number, number, number];\n\n/**\n * 4-dimensional vector, e.g. RGBA or a quaternion.\n * @hidden\n */\nexport type vec4 = [number, number, number, number];\n\n// prettier-ignore\n/**\n * 3x3 matrix, e.g. an affine transform of a 2D vector.\n * @hidden\n */\nexport type mat3 = [\n\tnumber, number, number,\n\tnumber, number, number,\n\tnumber, number, number,\n];\n\n// prettier-ignore\n/**\n * 4x4 matrix, e.g. an affine transform of a 3D vector.\n * @hidden\n */\nexport type mat4 = [\n\tnumber, number, number, number,\n\tnumber, number, number, number,\n\tnumber, number, number, number,\n\tnumber, number, number, number,\n];\n\n/** @hidden */\nexport type bbox = { min: vec3; max: vec3 };\n\n/** @hidden */\nexport const GLB_BUFFER = '@glb.bin';\n\n/**\n * Abstraction representing any one of the typed array classes supported by glTF and JavaScript.\n * @hidden\n */\nexport type TypedArray = Float32Array | Uint32Array | Uint16Array | Uint8Array | Int16Array | Int8Array;\n\n/**\n * Abstraction representing the typed array constructors supported by glTF and JavaScript.\n * @hidden\n */\nexport type TypedArrayConstructor =\n\t| Float32ArrayConstructor\n\t| Uint32ArrayConstructor\n\t| Uint16ArrayConstructor\n\t| Uint8ArrayConstructor\n\t| Int16ArrayConstructor\n\t| Int8ArrayConstructor;\n\n/** String IDs for core {@link Property} types. */\nexport enum PropertyType {\n\tACCESSOR = 'Accessor',\n\tANIMATION = 'Animation',\n\tANIMATION_CHANNEL = 'AnimationChannel',\n\tANIMATION_SAMPLER = 'AnimationSampler',\n\tBUFFER = 'Buffer',\n\tCAMERA = 'Camera',\n\tMATERIAL = 'Material',\n\tMESH = 'Mesh',\n\tPRIMITIVE = 'Primitive',\n\tPRIMITIVE_TARGET = 'PrimitiveTarget',\n\tNODE = 'Node',\n\tROOT = 'Root',\n\tSCENE = 'Scene',\n\tSKIN = 'Skin',\n\tTEXTURE = 'Texture',\n\tTEXTURE_INFO = 'TextureInfo',\n}\n\n/** Vertex layout method. */\nexport enum VertexLayout {\n\t/**\n\t * Stores vertex attributes in a single buffer view per mesh primitive. Interleaving vertex\n\t * data may improve performance by reducing page-thrashing in GPU memory.\n\t */\n\tINTERLEAVED = 'interleaved',\n\n\t/**\n\t * Stores each vertex attribute in a separate buffer view. May decrease performance by causing\n\t * page-thrashing in GPU memory. Some 3D engines may prefer this layout, e.g. for simplicity.\n\t */\n\tSEPARATE = 'separate',\n}\n\n/** Accessor usage. */\nexport enum BufferViewUsage {\n\tARRAY_BUFFER = 'ARRAY_BUFFER',\n\tELEMENT_ARRAY_BUFFER = 'ELEMENT_ARRAY_BUFFER',\n\tINVERSE_BIND_MATRICES = 'INVERSE_BIND_MATRICES',\n\tOTHER = 'OTHER',\n}\n\n/** Texture channels. */\nexport enum TextureChannel {\n\tR = 0x1000,\n\tG = 0x0100,\n\tB = 0x0010,\n\tA = 0x0001,\n}\n\nexport enum Format {\n\tGLTF = 'GLTF',\n\tGLB = 'GLB',\n}\n","import { transformMat4 } from 'gl-matrix/vec3';\nimport { PropertyType, bbox, mat4, vec3 } from '../constants';\nimport type { Mesh, Node, Scene } from '../properties';\n\n/**\n * Computes bounding box (AABB) in world space for the given {@link Node} or {@link Scene}.\n *\n * Example:\n *\n * ```ts\n * const {min, max} = bounds(scene);\n * ```\n */\nexport function bounds(node: Node | Scene): bbox {\n\tconst resultBounds = createBounds();\n\tconst parents = node.propertyType === PropertyType.NODE ? [node] : node.listChildren();\n\n\tfor (const parent of parents) {\n\t\tparent.traverse((node) => {\n\t\t\tconst mesh = node.getMesh();\n\t\t\tif (!mesh) return;\n\n\t\t\t// Compute mesh bounds and update result.\n\t\t\tconst meshBounds = getMeshBounds(mesh, node.getWorldMatrix());\n\t\t\texpandBounds(meshBounds.min, resultBounds);\n\t\t\texpandBounds(meshBounds.max, resultBounds);\n\t\t});\n\t}\n\n\treturn resultBounds;\n}\n\n/** Computes mesh bounds in local space. */\nfunction getMeshBounds(mesh: Mesh, worldMatrix: mat4): bbox {\n\tconst meshBounds = createBounds();\n\n\t// We can't transform a local AABB into world space and still have a tight AABB in world space,\n\t// so we need to compute the world AABB vertex by vertex here.\n\tfor (const prim of mesh.listPrimitives()) {\n\t\tconst position = prim.getAttribute('POSITION');\n\t\tif (!position) continue;\n\n\t\tlet localPos: vec3 = [0, 0, 0];\n\t\tlet worldPos: vec3 = [0, 0, 0];\n\t\tfor (let i = 0; i < position.getCount(); i++) {\n\t\t\tlocalPos = position.getElement(i, localPos) as vec3;\n\t\t\tworldPos = transformMat4(worldPos, localPos, worldMatrix) as vec3;\n\t\t\texpandBounds(worldPos, meshBounds);\n\t\t}\n\t}\n\n\treturn meshBounds;\n}\n\n/** Expands bounds of target by given source. */\nfunction expandBounds(point: vec3, target: bbox): void {\n\tfor (let i = 0; i < 3; i++) {\n\t\ttarget.min[i] = Math.min(point[i], target.min[i]);\n\t\ttarget.max[i] = Math.max(point[i], target.max[i]);\n\t}\n}\n\n/** Creates new bounds with min=Infinity, max=-Infinity. */\nfunction createBounds(): bbox {\n\treturn {\n\t\tmin: [Infinity, Infinity, Infinity] as vec3,\n\t\tmax: [-Infinity, -Infinity, -Infinity] as vec3,\n\t};\n}\n","import { TypedArray } from '../constants';\n\n/**\n * # BufferUtils\n *\n * *Common utilities for working with Uint8Array and Buffer objects.*\n *\n * @category Utilities\n */\nexport class BufferUtils {\n\t/** Creates a byte array from a Data URI. */\n\tstatic createBufferFromDataURI(dataURI: string): Uint8Array {\n\t\tif (typeof Buffer === 'undefined') {\n\t\t\t// Browser.\n\t\t\tconst byteString = atob(dataURI.split(',')[1]);\n\t\t\tconst ia = new Uint8Array(byteString.length);\n\t\t\tfor (let i = 0; i < byteString.length; i++) {\n\t\t\t\tia[i] = byteString.charCodeAt(i);\n\t\t\t}\n\t\t\treturn ia;\n\t\t} else {\n\t\t\t// Node.js.\n\t\t\tconst data = dataURI.split(',')[1];\n\t\t\tconst isBase64 = dataURI.indexOf('base64') >= 0;\n\t\t\treturn Buffer.from(data, isBase64 ? 'base64' : 'utf8');\n\t\t}\n\t}\n\n\t/** Encodes text to a byte array. */\n\tstatic encodeText(text: string): Uint8Array {\n\t\tif (typeof TextEncoder !== 'undefined') {\n\t\t\treturn new TextEncoder().encode(text);\n\t\t}\n\t\treturn Buffer.from(text);\n\t}\n\n\t/** Decodes a byte array to text. */\n\tstatic decodeText(array: Uint8Array): string {\n\t\tif (typeof TextDecoder !== 'undefined') {\n\t\t\treturn new TextDecoder().decode(array);\n\t\t}\n\t\treturn Buffer.from(array).toString('utf8');\n\t}\n\n\t/**\n\t * Concatenates N byte arrays.\n\t */\n\tstatic concat(arrays: Uint8Array[]): Uint8Array {\n\t\tlet totalByteLength = 0;\n\t\tfor (const array of arrays) {\n\t\t\ttotalByteLength += array.byteLength;\n\t\t}\n\n\t\tconst result = new Uint8Array(totalByteLength);\n\t\tlet byteOffset = 0;\n\n\t\tfor (const array of arrays) {\n\t\t\tresult.set(array, byteOffset);\n\t\t\tbyteOffset += array.byteLength;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Pads a Uint8Array to the next 4-byte boundary.\n\t *\n\t * Reference: [glTF → Data Alignment](https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment)\n\t */\n\tstatic pad(srcArray: Uint8Array, paddingByte = 0): Uint8Array {\n\t\tconst paddedLength = this.padNumber(srcArray.byteLength);\n\t\tif (paddedLength === srcArray.byteLength) return srcArray;\n\n\t\tconst dstArray = new Uint8Array(paddedLength);\n\t\tdstArray.set(srcArray);\n\n\t\tif (paddingByte !== 0) {\n\t\t\tfor (let i = srcArray.byteLength; i < paddedLength; i++) {\n\t\t\t\tdstArray[i] = paddingByte;\n\t\t\t}\n\t\t}\n\n\t\treturn dstArray;\n\t}\n\n\t/** Pads a number to 4-byte boundaries. */\n\tstatic padNumber(v: number): number {\n\t\treturn Math.ceil(v / 4) * 4;\n\t}\n\n\t/** Returns true if given byte array instances are equal. */\n\tstatic equals(a: Uint8Array, b: Uint8Array): boolean {\n\t\tif (a === b) return true;\n\n\t\tif (a.byteLength !== b.byteLength) return false;\n\n\t\tlet i = a.byteLength;\n\t\twhile (i--) {\n\t\t\tif (a[i] !== b[i]) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns a Uint8Array view of a typed array, with the same underlying ArrayBuffer.\n\t *\n\t * A shorthand for:\n\t *\n\t * ```js\n\t * const buffer = new Uint8Array(\n\t * \tarray.buffer,\n\t * \tarray.byteOffset + byteOffset,\n\t * \tMath.min(array.byteLength, byteLength)\n\t * );\n\t * ```\n\t *\n\t */\n\tstatic toView(a: TypedArray, byteOffset = 0, byteLength = Infinity): Uint8Array {\n\t\treturn new Uint8Array(a.buffer, a.byteOffset + byteOffset, Math.min(a.byteLength, byteLength));\n\t}\n\n\t/** @internal */\n\tstatic assertView(view: null): null;\n\tstatic assertView(view: Uint8Array): Uint8Array;\n\tstatic assertView(view: Uint8Array | null): Uint8Array | null;\n\tstatic assertView(view: Uint8Array | null): Uint8Array | null {\n\t\tif (view && !ArrayBuffer.isView(view)) {\n\t\t\tthrow new Error(`Method requires Uint8Array parameter; received \"${typeof view}\".`);\n\t\t}\n\t\treturn view as Uint8Array;\n\t}\n}\n","import { vec3, vec4 } from '../constants';\n\n/**\n * # ColorUtils\n *\n * *Common utilities for working with colors in vec3, vec4, or hexadecimal form.*\n *\n * Provides methods to convert linear components (vec3, vec4) to sRGB hex values. All colors in\n * the glTF specification, excluding color textures, are linear. Hexadecimal values, in sRGB\n * colorspace, are accessible through helper functions in the API as a convenience.\n *\n * ```typescript\n * // Hex (sRGB) to factor (linear).\n * const factor = ColorUtils.hexToFactor(0xFFCCCC, []);\n *\n * // Factor (linear) to hex (sRGB).\n * const hex = ColorUtils.factorToHex([1, .25, .25])\n * ```\n *\n * @category Utilities\n */\nexport class ColorUtils {\n\t/**\n\t * Converts sRGB hexadecimal to linear components.\n\t * @typeParam T vec3 or vec4 linear components.\n\t */\n\tstatic hexToFactor<T = vec3 | vec4>(hex: number, target: T): T {\n\t\thex = Math.floor(hex);\n\t\tconst _target = target as unknown as vec3;\n\t\t_target[0] = ((hex >> 16) & 255) / 255;\n\t\t_target[1] = ((hex >> 8) & 255) / 255;\n\t\t_target[2] = (hex & 255) / 255;\n\t\treturn this.convertSRGBToLinear<T>(target, target);\n\t}\n\n\t/**\n\t * Converts linear components to sRGB hexadecimal.\n\t * @typeParam T vec3 or vec4 linear components.\n\t */\n\tstatic factorToHex<T = vec3 | vec4>(factor: T): number {\n\t\tconst target = [...(factor as unknown as number[])] as unknown as T;\n\t\tconst [r, g, b] = this.convertLinearToSRGB(factor, target) as unknown as number[];\n\t\treturn ((r * 255) << 16) ^ ((g * 255) << 8) ^ ((b * 255) << 0);\n\t}\n\n\t/**\n\t * Converts sRGB components to linear components.\n\t * @typeParam T vec3 or vec4 linear components.\n\t */\n\tstatic convertSRGBToLinear<T = vec3 | vec4>(source: T, target: T): T {\n\t\tconst _source = source as unknown as vec3;\n\t\tconst _target = target as unknown as vec3;\n\t\tfor (let i = 0; i < 3; i++) {\n\t\t\t_target[i] =\n\t\t\t\t_source[i] < 0.04045\n\t\t\t\t\t? _source[i] * 0.0773993808\n\t\t\t\t\t: Math.pow(_source[i] * 0.9478672986 + 0.0521327014, 2.4);\n\t\t}\n\t\treturn target;\n\t}\n\n\t/**\n\t * Converts linear components to sRGB components.\n\t * @typeParam T vec3 or vec4 linear components.\n\t */\n\tstatic convertLinearToSRGB<T = vec3 | vec4>(source: T, target: T): T {\n\t\tconst _source = source as unknown as vec3;\n\t\tconst _target = target as unknown as vec3;\n\t\tfor (let i = 0; i < 3; i++) {\n\t\t\t_target[i] = _source[i] < 0.0031308 ? _source[i] * 12.92 : 1.055 * Math.pow(_source[i], 0.41666) - 0.055;\n\t\t}\n\t\treturn target;\n\t}\n}\n","// Need a placeholder domain to construct a URL from a relative path. We only\n// access `url.pathname`, so the domain doesn't matter.\nconst NULL_DOMAIN = 'https://null.example';\n\n/**\n * # FileUtils\n *\n * *Utility class for working with file systems and URI paths.*\n *\n * @category Utilities\n */\nexport class FileUtils {\n\t/** Extracts the basename from a path, e.g. \"folder/model.glb\" -> \"model\". */\n\tstatic basename(path: string): string {\n\t\tpath = new URL(path, NULL_DOMAIN).pathname;\n\t\tconst fileName = path.split(/[\\\\/]/).pop()!;\n\t\treturn fileName.substring(0, fileName.lastIndexOf('.'));\n\t}\n\n\t/** Extracts the extension from a path, e.g. \"folder/model.glb\" -> \"glb\". */\n\tstatic extension(path: string): string {\n\t\tif (path.indexOf('data:') !== 0) {\n\t\t\tpath = new URL(path, NULL_DOMAIN).pathname;\n\t\t\treturn path.split(/[\\\\/]/).pop()!.split(/[.]/).pop()!;\n\t\t} else if (path.indexOf('data:image/png') === 0) {\n\t\t\treturn 'png';\n\t\t} else if (path.indexOf('data:image/jpeg') === 0) {\n\t\t\treturn 'jpeg';\n\t\t} else {\n\t\t\treturn 'bin';\n\t\t}\n\t}\n}\n","import { vec2 } from '../constants';\nimport { BufferUtils } from './buffer-utils';\n\n/** Implements support for an image format in the {@link ImageUtils} class. */\nexport interface ImageUtilsFormat {\n\tmatch(buffer: Uint8Array): boolean;\n\tgetSize(buffer: Uint8Array): vec2 | null;\n\tgetChannels(buffer: Uint8Array): number | null;\n\tgetGPUByteLength?(buffer: Uint8Array): number | null;\n}\n\n/** JPEG image support. */\nclass JPEGImageUtils implements ImageUtilsFormat {\n\tmatch(array: Uint8Array): boolean {\n\t\treturn array.length >= 3 && array[0] === 255 && array[1] === 216 && array[2] === 255;\n\t}\n\tgetSize(array: Uint8Array): vec2 {\n\t\t// Skip 4 chars, they are for signature\n\t\tlet view = new DataView(array.buffer, array.byteOffset + 4);\n\n\t\tlet i: number, next: number;\n\t\twhile (view.byteLength) {\n\t\t\t// read length of the next block\n\t\t\ti = view.getUint16(0, false);\n\t\t\t// i = buffer.readUInt16BE(0);\n\n\t\t\t// ensure correct format\n\t\t\tvalidateJPEGBuffer(view, i);\n\n\t\t\t// 0xFFC0 is baseline standard(SOF)\n\t\t\t// 0xFFC1 is baseline optimized(SOF)\n\t\t\t// 0xFFC2 is progressive(SOF2)\n\t\t\tnext = view.getUint8(i + 1);\n\t\t\tif (next === 0xc0 || next === 0xc1 || next === 0xc2) {\n\t\t\t\treturn [view.getUint16(i + 7, false), view.getUint16(i + 5, false)];\n\t\t\t}\n\n\t\t\t// move to the next block\n\t\t\tview = new DataView(array.buffer, view.byteOffset + i + 2);\n\t\t}\n\n\t\tthrow new TypeError('Invalid JPG, no size found');\n\t}\n\n\tgetChannels(_buffer: Uint8Array): number {\n\t\treturn 3;\n\t}\n}\n\n/**\n * PNG image support.\n *\n * PNG signature: 'PNG\\r\\n\\x1a\\n'\n * PNG image header chunk name: 'IHDR'\n */\nclass PNGImageUtils implements ImageUtilsFormat {\n\t// Used to detect \"fried\" png's: http://www.jongware.com/pngdefry.html\n\tstatic PNG_FRIED_CHUNK_NAME = 'CgBI';\n\tmatch(array: Uint8Array): boolean {\n\t\treturn (\n\t\t\tarray.length >= 8 &&\n\t\t\tarray[0] === 0x89 &&\n\t\t\tarray[1] === 0x50 &&\n\t\t\tarray[2] === 0x4e &&\n\t\t\tarray[3] === 0x47 &&\n\t\t\tarray[4] === 0x0d &&\n\t\t\tarray[5] === 0x0a &&\n\t\t\tarray[6] === 0x1a &&\n\t\t\tarray[7] === 0x0a\n\t\t);\n\t}\n\tgetSize(array: Uint8Array): vec2 {\n\t\tconst view = new DataView(array.buffer, array.byteOffset);\n\t\tconst magic = BufferUtils.decodeText(array.slice(12, 16));\n\t\tif (magic === PNGImageUtils.PNG_FRIED_CHUNK_NAME) {\n\t\t\treturn [view.getUint32(32, false), view.getUint32(36, false)];\n\t\t}\n\t\treturn [view.getUint32(16, false), view.getUint32(20, false)];\n\t}\n\tgetChannels(_buffer: Uint8Array): number {\n\t\treturn 4;\n\t}\n}\n\n/**\n * # ImageUtils\n *\n * *Common utilities for working with image data.*\n *\n * @category Utilities\n */\nexport class ImageUtils {\n\tstatic impls: Record<string, ImageUtilsFormat> = {\n\t\t'image/jpeg': new JPEGImageUtils(),\n\t\t'image/png': new PNGImageUtils(),\n\t};\n\n\t/** Registers support for a new image format; useful for certain extensions. */\n\tpublic static registerFormat(mimeType: string, impl: ImageUtilsFormat): void {\n\t\tthis.impls[mimeType] = impl;\n\t}\n\n\t/**\n\t * Returns detected MIME type of the given image buffer. Note that for image\n\t * formats with support provided by extensions, the extension must be\n\t * registered with an I/O class before it can be detected by ImageUtils.\n\t */\n\tpublic static getMimeType(buffer: Uint8Array): string | null {\n\t\tfor (const mimeType in this.impls) {\n\t\t\tif (this.impls[mimeType].match(buffer)) {\n\t\t\t\treturn mimeType;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Returns the dimensions of the image. */\n\tpublic static getSize(buffer: Uint8Array, mimeType: string): vec2 | null {\n\t\tif (!this.impls[mimeType]) return null;\n\t\treturn this.impls[mimeType].getSize(buffer);\n\t}\n\n\t/**\n\t * Returns a conservative estimate of the number of channels in the image. For some image\n\t * formats, the method may return 4 indicating the possibility of an alpha channel, without\n\t * the ability to guarantee that an alpha channel is present.\n\t */\n\tpublic static getChannels(buffer: Uint8Array, mimeType: string): number | null {\n\t\tif (!this.impls[mimeType]) return null;\n\t\treturn this.impls[mimeType].getChannels(buffer);\n\t}\n\n\t/** Returns a conservative estimate of the GPU memory required by this image. */\n\tpublic static getMemSize(buffer: Uint8Array, mimeType: string): number | null {\n\t\tif (!this.impls[mimeType]) return null;\n\n\t\tif (this.impls[mimeType].getGPUByteLength) {\n\t\t\treturn this.impls[mimeType].getGPUByteLength!(buffer);\n\t\t}\n\n\t\tlet uncompressedBytes = 0;\n\t\tconst channels = 4; // See https://github.com/donmccurdy/glTF-Transform/issues/151.\n\t\tconst resolution = this.getSize(buffer, mimeType);\n\t\tif (!resolution) return null;\n\n\t\twhile (resolution[0] > 1 || resolution[1] > 1) {\n\t\t\tuncompressedBytes += resolution[0] * resolution[1] * channels;\n\t\t\tresolution[0] = Math.max(Math.floor(resolution[0] / 2), 1);\n\t\t\tresolution[1] = Math.max(Math.floor(resolution[1] / 2), 1);\n\t\t}\n\t\tuncompressedBytes += 1 * 1 * channels;\n\t\treturn uncompressedBytes;\n\t}\n\n\t/** Returns the preferred file extension for the given MIME type. */\n\tpublic static mimeTypeToExtension(mimeType: string): string {\n\t\tif (mimeType === 'image/jpeg') return 'jpg';\n\t\treturn mimeType.split('/').pop()!;\n\t}\n\n\t/** Returns the MIME type for the given file extension. */\n\tpublic static extensionToMimeType(extension: string): string {\n\t\tif (extension === 'jpg') return 'image/jpeg';\n\t\treturn `image/${extension}`;\n\t}\n}\n\nfunction validateJPEGBuffer(view: DataView, i: number): DataView {\n\t// index should be within buffer limits\n\tif (i > view.byteLength) {\n\t\tthrow new TypeError('Corrupt JPG, exceeded buffer limits');\n\t}\n\t// Every JPEG block must begin with a 0xFF\n\tif (view.getUint8(i) !== 0xff) {\n\t\tthrow new TypeError('Invalid JPG, marker table corrupted');\n\t}\n\n\treturn view;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n// Reference: https://github.com/jonschlinkert/is-plain-object\n\nfunction isObject(o: any) {\n\treturn Object.prototype.toString.call(o) === '[object Object]';\n}\n\nexport function isPlainObject(o: any) {\n\tif (isObject(o) === false) return false;\n\n\t// If has modified constructor\n\tconst ctor = o.constructor;\n\tif (ctor === undefined) return true;\n\n\t// If has modified prototype\n\tconst prot = ctor.prototype;\n\tif (isObject(prot) === false) return false;\n\n\t// If constructor does not have an Object-specific method\n\tif (Object.prototype.hasOwnProperty.call(prot, 'isPrototypeOf') === false) {\n\t\treturn false;\n\t}\n\n\t// Most likely a plain Object\n\treturn true;\n}\n","/**\n * # Logger\n *\n * *Logger utility class.*\n *\n * @category Utilities\n */\nclass Logger {\n\t/**\n\t * Log verbosity thresholds.\n\t */\n\tstatic Verbosity = {\n\t\t/** No events are logged. */\n\t\tSILENT: 4,\n\n\t\t/** Only error events are logged. */\n\t\tERROR: 3,\n\n\t\t/** Only error and warn events are logged. */\n\t\tWARN: 2,\n\n\t\t/** Only error, warn, and info events are logged. (DEFAULT) */\n\t\tINFO: 1,\n\n\t\t/** All events are logged. */\n\t\tDEBUG: 0,\n\t};\n\n\t/** Default logger instance. */\n\tpublic static DEFAULT_INSTANCE = new Logger(Logger.Verbosity.INFO);\n\n\t/** Constructs a new Logger instance. */\n\tconstructor(private readonly verbosity: number) {}\n\n\t/** Logs an event at level {@link Logger.Verbosity.DEBUG}. */\n\tdebug(text: string): void {\n\t\tif (this.verbosity <= Logger.Verbosity.DEBUG) {\n\t\t\tconsole.debug(text);\n\t\t}\n\t}\n\n\t/** Logs an event at level {@link Logger.Verbosity.INFO}. */\n\tinfo(text: string): void {\n\t\tif (this.verbosity <= Logger.Verbosity.INFO) {\n\t\t\tconsole.info(text);\n\t\t}\n\t}\n\n\t/** Logs an event at level {@link Logger.Verbosity.WARN}. */\n\twarn(text: string): void {\n\t\tif (this.verbosity <= Logger.Verbosity.WARN) {\n\t\t\tconsole.warn(text);\n\t\t}\n\t}\n\n\t/** Logs an event at level {@link Logger.Verbosity.ERROR}. */\n\terror(text: string): void {\n\t\tif (this.verbosity <= Logger.Verbosity.ERROR) {\n\t\t\tconsole.error(text);\n\t\t}\n\t}\n}\n\nexport { Logger };\n","import { determinant, getRotation } from 'gl-matrix/mat4';\nimport { length } from 'gl-matrix/vec3';\nimport { mat4, vec3, vec4 } from '../constants';\nimport { GLTF } from '../types/gltf';\n\n/** @hidden */\nexport class MathUtils {\n\tpublic static identity(v: number): number {\n\t\treturn v;\n\t}\n\n\tpublic static eq(a: number[], b: number[]): boolean {\n\t\tif (a.length !== b.length) return false;\n\n\t\tconst eps = 10e-6;\n\t\tfor (let i = 0; i < a.length; i++) {\n\t\t\tif (Math.abs(a[i] - b[i]) > eps) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic static denormalize(c: number, componentType: GLTF.AccessorComponentType): number {\n\t\t// Hardcode enums from accessor.ts to avoid a circular dependency.\n\t\tswitch (componentType) {\n\t\t\tcase 5126:\n\t\t\t\treturn c;\n\t\t\tcase 5123:\n\t\t\t\treturn c / 65535.0;\n\t\t\tcase 5121:\n\t\t\t\treturn c / 255.0;\n\t\t\tcase 5122:\n\t\t\t\treturn Math.max(c / 32767.0, -1.0);\n\t\t\tcase 5120:\n\t\t\t\treturn Math.max(c / 127.0, -1.0);\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Invalid component type.');\n\t\t}\n\t}\n\n\tpublic static normalize(f: number, componentType: GLTF.AccessorComponentType): number {\n\t\t// Hardcode enums from accessor.ts to avoid a circular dependency.\n\t\tswitch (componentType) {\n\t\t\tcase 5126:\n\t\t\t\treturn f;\n\t\t\tcase 5123:\n\t\t\t\treturn Math.round(f * 65535.0);\n\t\t\tcase 5121:\n\t\t\t\treturn Math.round(f * 255.0);\n\t\t\tcase 5122:\n\t\t\t\treturn Math.round(f * 32767.0);\n\t\t\tcase 5120:\n\t\t\t\treturn Math.round(f * 127.0);\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Invalid component type.');\n\t\t}\n\t}\n\n\t/**\n\t * Decompose a mat4 to TRS properties.\n\t *\n\t * Equivalent to the Matrix4 decompose() method in three.js, and intentionally not using the\n\t * gl-matrix version. See: https://github.com/toji/gl-matrix/issues/408\n\t *\n\t * @param srcMat Matrix element, to be decomposed to TRS properties.\n\t * @param dstTranslation Translation element, to be overwritten.\n\t * @param dstRotation Rotation element, to be overwritten.\n\t * @param dstScale Scale element, to be overwritten.\n\t */\n\tpublic static decompose(srcMat: mat4, dstTranslation: vec3, dstRotation: vec4, dstScale: vec3): void {\n\t\tlet sx = length([srcMat[0], srcMat[1], srcMat[2]]);\n\t\tconst sy = length([srcMat[4], srcMat[5], srcMat[6]]);\n\t\tconst sz = length([srcMat[8], srcMat[9], srcMat[10]]);\n\n\t\t// if determine is negative, we need to invert one scale\n\t\tconst det = determinant(srcMat);\n\t\tif (det < 0) sx = -sx;\n\n\t\tdstTranslation[0] = srcMat[12];\n\t\tdstTranslation[1] = srcMat[13];\n\t\tdstTranslation[2] = srcMat[14];\n\n\t\t// scale the rotation part\n\t\tconst _m1 = srcMat.slice();\n\n\t\tconst invSX = 1 / sx;\n\t\tconst invSY = 1 / sy;\n\t\tconst invSZ = 1 / sz;\n\n\t\t_m1[0] *= invSX;\n\t\t_m1[1] *= invSX;\n\t\t_m1[2] *= invSX;\n\n\t\t_m1[4] *= invSY;\n\t\t_m1[5] *= invSY;\n\t\t_m1[6] *= invSY;\n\n\t\t_m1[8] *= invSZ;\n\t\t_m1[9] *= invSZ;\n\t\t_m1[10] *= invSZ;\n\n\t\tgetRotation(dstRotation, _m1 as mat4);\n\n\t\tdstScale[0] = sx;\n\t\tdstScale[1] = sy;\n\t\tdstScale[2] = sz;\n\t}\n\n\t/**\n\t * Compose TRS properties to a mat4.\n\t *\n\t * Equivalent to the Matrix4 compose() method in three.js, and intentionally not using the\n\t * gl-matrix version. See: https://github.com/toji/gl-matrix/issues/408\n\t *\n\t * @param srcTranslation Translation element of matrix.\n\t * @param srcRotation Rotation element of matrix.\n\t * @param srcScale Scale element of matrix.\n\t * @param dstMat Matrix element, to be modified and returned.\n\t * @returns dstMat, overwritten to mat4 equivalent of given TRS properties.\n\t */\n\tpublic static compose(srcTranslation: vec3, srcRotation: vec4, srcScale: vec3, dstMat: mat4): mat4 {\n\t\tconst te = dstMat;\n\n\t\tconst x = srcRotation[0],\n\t\t\ty = srcRotation[1],\n\t\t\tz = srcRotation[2],\n\t\t\tw = srcRotation[3];\n\t\tconst x2 = x + x,\n\t\t\ty2 = y + y,\n\t\t\tz2 = z + z;\n\t\tconst xx = x * x2,\n\t\t\txy = x * y2,\n\t\t\txz = x * z2;\n\t\tconst yy = y * y2,\n\t\t\tyz = y * z2,\n\t\t\tzz = z * z2;\n\t\tconst wx = w * x2,\n\t\t\twy = w * y2,\n\t\t\twz = w * z2;\n\n\t\tconst sx = srcScale[0],\n\t\t\tsy = srcScale[1],\n\t\t\tsz = srcScale[2];\n\n\t\tte[0] = (1 - (yy + zz)) * sx;\n\t\tte[1] = (xy + wz) * sx;\n\t\tte[2] = (xz - wy) * sx;\n\t\tte[3] = 0;\n\n\t\tte[4] = (xy - wz) * sy;\n\t\tte[5] = (1 - (xx + zz)) * sy;\n\t\tte[6] = (yz + wx) * sy;\n\t\tte[7] = 0;\n\n\t\tte[8] = (xz + wy) * sz;\n\t\tte[9] = (yz - wx) * sz;\n\t\tte[10] = (1 - (xx + yy)) * sz;\n\t\tte[11] = 0;\n\n\t\tte[12] = srcTranslation[0];\n\t\tte[13] = srcTranslation[1];\n\t\tte[14] = srcTranslation[2];\n\t\tte[15] = 1;\n\n\t\treturn te;\n\t}\n}\n","import { GraphEdge } from 'property-graph';\nimport { isPlainObject } from './is-plain-object';\nimport { BufferViewUsage } from '../constants';\nimport type { Property } from '../properties';\n\nexport type Ref = GraphEdge<Property, Property>;\nexport type RefMap = { [key: string]: Ref };\nexport type UnknownRef = Ref | Ref[] | RefMap | unknown;\n\nexport function equalsRef(refA: Ref, refB: Ref): boolean {\n\tif (!!refA !== !!refB) return false;\n\n\tconst a = refA.getChild();\n\tconst b = refB.getChild();\n\n\treturn a === b || a.equals(b);\n}\n\nexport function equalsRefList(refListA: Ref[], refListB: Ref[]): boolean {\n\tif (!!refListA !== !!refListB) return false;\n\tif (refListA.length !== refListB.length) return false;\n\n\tfor (let i = 0; i < refListA.length; i++) {\n\t\tconst a = refListA[i];\n\t\tconst b = refListB[i];\n\n\t\tif (a.getChild() === b.getChild()) continue;\n\n\t\tif (!a.getChild().equals(b.getChild())) return false;\n\t}\n\n\treturn true;\n}\n\nexport function equalsRefMap(refMapA: RefMap, refMapB: RefMap): boolean {\n\tif (!!refMapA !== !!refMapB) return false;\n\n\tconst keysA = Object.keys(refMapA);\n\tconst keysB = Object.keys(refMapB);\n\tif (keysA.length !== keysB.length) return false;\n\n\tfor (const key in refMapA) {\n\t\tconst refA = refMapA[key];\n\t\tconst refB = refMapB[key];\n\t\tif (!!refA !== !!refB) return false;\n\n\t\tconst a = refA.getChild();\n\t\tconst b = refB.getChild();\n\t\tif (a === b) continue;\n\n\t\tif (!a.equals(b)) return false;\n\t}\n\n\treturn true;\n}\n\nexport function equalsArray(a: ArrayLike<unknown> | null, b: ArrayLike<unknown> | null): boolean {\n\tif (a === b) return true;\n\n\tif (!!a !== !!b || !a || !b) return false;\n\n\tif (a.length !== b.length) return false;\n\n\tfor (let i = 0; i < a.length; i++) {\n\t\tif (a[i] !== b[i]) return false;\n\t}\n\n\treturn true;\n}\n\nexport function equalsObject(_a: unknown, _b: unknown): boolean {\n\tif (_a === _b) return true;\n\tif (!!_a !== !!_b) return false;\n\tif (!isPlainObject(_a) || !isPlainObject(_b)) {\n\t\treturn _a === _b;\n\t}\n\n\tconst a = _a as Record<string, unknown>;\n\tconst b = _b as Record<string, unknown>;\n\n\tlet numKeysA = 0;\n\tlet numKeysB = 0;\n\n\tlet key: string;\n\n\tfor (key in a) numKeysA++;\n\tfor (key in b) numKeysB++;\n\tif (numKeysA !== numKeysB) return false;\n\n\tfor (key in a) {\n\t\tconst valueA = a[key];\n\t\tconst valueB = b[key];\n\t\tif (isArray(valueA) && isArray(valueB)) {\n\t\t\tif (!equalsArray(valueA as [], valueB as [])) return false;\n\t\t} else if (isPlainObject(valueA) && isPlainObject(valueB)) {\n\t\t\tif (!equalsObject(valueA, valueB)) return false;\n\t\t} else {\n\t\t\tif (valueA !== valueB) return false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nexport type RefAttributes = Record<string, unknown>;\n\nexport interface AccessorRefAttributes extends RefAttributes {\n\t/** Usage role of an accessor reference. */\n\tusage: BufferViewUsage | string;\n}\n\nexport interface TextureRefAttributes extends RefAttributes {\n\t/** Bitmask for {@link TextureChannel TextureChannels} used by a texture reference. */\n\tchannels: number;\n}\n\nexport function isArray(value: unknown): boolean {\n\treturn Array.isArray(value) || ArrayBuffer.isView(value);\n}\n","const ALPHABET = '23456789abdegjkmnpqrvwxyzABDEGJKMNPQRVWXYZ';\nconst UNIQUE_RETRIES = 999;\nconst ID_LENGTH = 6;\n\nconst previousIDs = new Set();\n\nconst generateOne = function (): string {\n\tlet rtn = '';\n\tfor (let i = 0; i < ID_LENGTH; i++) {\n\t\trtn += ALPHABET.charAt(Math.floor(Math.random() * ALPHABET.length));\n\t}\n\treturn rtn;\n};\n\n/**\n * Short ID generator.\n *\n * Generated IDs are short, easy to type, and unique for the duration of the program's execution.\n * Uniqueness across multiple program executions, or on other devices, is not guaranteed. Based on\n * [Short ID Generation in JavaScript](https://tomspencer.dev/blog/2014/11/16/short-id-generation-in-javascript/),\n * with alterations.\n *\n * @category Utilities\n * @hidden\n */\nexport const uuid = function (): string {\n\tfor (let retries = 0; retries < UNIQUE_RETRIES; retries++) {\n\t\tconst id = generateOne();\n\t\tif (!previousIDs.has(id)) {\n\t\t\tpreviousIDs.add(id);\n\t\t\treturn id;\n\t\t}\n\t}\n\treturn '';\n};\n","/** @internal */\nexport class HTTPUtils {\n\tstatic readonly DEFAULT_INIT: RequestInit = {};\n\tstatic readonly PROTOCOL_REGEXP = /^[a-zA-Z]+:\\/\\//;\n\n\tstatic dirname(path: string): string {\n\t\tconst index = path.lastIndexOf('/');\n\t\tif (index === -1) return './';\n\t\treturn path.substring(0, index + 1);\n\t}\n\n\tstatic resolve(base: string, path: string) {\n\t\tif (!this.isRelativePath(path)) return path;\n\n\t\tconst stack = base.split('/');\n\t\tconst parts = path.split('/');\n\t\tstack.pop();\n\t\tfor (let i = 0; i < parts.length; i++) {\n\t\t\tif (parts[i] === '.') continue;\n\t\t\tif (parts[i] === '..') {\n\t\t\t\tstack.pop();\n\t\t\t} else {\n\t\t\t\tstack.push(parts[i]);\n\t\t\t}\n\t\t}\n\t\treturn stack.join('/');\n\t}\n\n\t/**\n\t * Returns true for URLs containing a protocol, and false for both\n\t * absolute and relative paths.\n\t */\n\tstatic isAbsoluteURL(path: string) {\n\t\treturn this.PROTOCOL_REGEXP.test(path);\n\t}\n\n\t/**\n\t * Returns true for paths that are declared relative to some unknown base\n\t * path. For example, \"foo/bar/\" is relative both \"/foo/bar/\" is not.\n\t */\n\tstatic isRelativePath(path: string): boolean {\n\t\treturn !/^(?:[a-zA-Z]+:)?\\//.test(path);\n\t}\n}\n","import { Nullable } from '../constants';\nimport { $attributes, $immutableKeys, Graph, GraphNode, GraphEdge, isRef, isRefList, isRefMap } from 'property-graph';\nimport { equalsArray, equalsObject, equalsRef, equalsRefList, equalsRefMap, isArray, isPlainObject } from '../utils';\nimport type { Ref, RefMap, UnknownRef } from '../utils';\n\nexport type PropertyResolver<T extends Property> = (p: T) => T;\nexport const COPY_IDENTITY = <T extends Property>(t: T): T => t;\n\nexport interface IProperty {\n\tname: string;\n\textras: Record<string, unknown>;\n}\n\n/**\n * # Property\n *\n * *Properties represent distinct resources in a glTF asset, referenced by other properties.*\n *\n * For example, each material and texture is a property, with material properties holding\n * references to the textures. All properties are created with factory methods on the\n * {@link Document} in which they should be constructed. Properties are destroyed by calling\n * {@link dispose}().\n *\n * Usage:\n *\n * ```ts\n * const texture = doc.createTexture('myTexture');\n * doc.listTextures(); // → [texture x 1]\n *\n * // Attach a texture to a material.\n * material.setBaseColorTexture(texture);\n * material.getBaseColortexture(); // → texture\n *\n * // Detaching a texture removes any references to it, except from the doc.\n * texture.detach();\n * material.getBaseColorTexture(); // → null\n * doc.listTextures(); // → [texture x 1]\n *\n * // Disposing a texture removes all references to it, and its own references.\n * texture.dispose();\n * doc.listTextures(); // → []\n * ```\n *\n * Reference:\n * - [glTF → Concepts](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#concepts)\n *\n * @category Properties\n */\nexport abstract class Property<T extends IProperty = IProperty> extends GraphNode<T> {\n\t/** Property type. */\n\tpublic abstract readonly propertyType: string;\n\n\t/**\n\t * Internal graph used to search and maintain references.\n\t * @override\n\t * @hidden\n\t */\n\tprotected declare readonly graph: Graph<Property>;\n\n\t/** @hidden */\n\tconstructor(graph: Graph<Property>, name = '') {\n\t\tsuper(graph);\n\t\t(this as Property)[$attributes]['name'] = name;\n\t\tthis.init();\n\t\tthis.dispatchEvent({ type: 'create' });\n\t}\n\n\t/**\n\t * Initializes instance data for a subclass. Because subclass constructors run after the\n\t * constructor of the parent class, and 'create' events dispatched by the parent class\n\t * assume the instance is fully initialized, it's best to do any initialization here.\n\t * @hidden\n\t */\n\tprotected abstract init(): void;\n\n\t/**\n\t * Returns default attributes for the property. Empty lists and maps should be initialized\n\t * to empty arrays and objects. Always invoke `super.getDefaults()` and extend the result.\n\t */\n\tprotected getDefaults(): Nullable<T> {\n\t\treturn Object.assign(super.getDefaults(), { name: '', extras: {} });\n\t}\n\n\t/**********************************************************************************************\n\t * Name.\n\t */\n\n\t/**\n\t * Returns the name of this property. While names are not required to be unique, this is\n\t * encouraged, and non-unique names will be overwritten in some tools. For custom data about\n\t * a property, prefer to use Extras.\n\t */\n\tpublic getName(): string {\n\t\treturn (this as Property).get('name');\n\t}\n\n\t/**\n\t * Sets the name of this property. While names are not required to be unique, this is\n\t * encouraged, and non-unique names will be overwritten in some tools. For custom data about\n\t * a property, prefer to use Extras.\n\t */\n\tpublic setName(name: string): this {\n\t\treturn (this as Property).set('name', name) as this;\n\t}\n\n\t/**********************************************************************************************\n\t * Extras.\n\t */\n\n\t/**\n\t * Returns a reference to the Extras object, containing application-specific data for this\n\t * Property. Extras should be an Object, not a primitive value, for best portability.\n\t */\n\tpublic getExtras(): Record<string, unknown> {\n\t\treturn (this as Property).get('extras');\n\t}\n\n\t/**\n\t * Updates the Extras object, containing application-specific data for this Property. Extras\n\t * should be an Object, not a primitive value, for best portability.\n\t */\n\tpublic setExtras(extras: Record<string, unknown>): this {\n\t\treturn (this as Property).set('extras', extras) as this;\n\t}\n\n\t/**********************************************************************************************\n\t * Graph state.\n\t */\n\n\t/**\n\t * Makes a copy of this property, with the same resources (by reference) as the original.\n\t */\n\tpublic clone(): this {\n\t\tconst PropertyClass = this.constructor as new (g: Graph<Property>) => this;\n\t\treturn new PropertyClass(this.graph).copy(this, COPY_IDENTITY);\n\t}\n\n\t/**\n\t * Copies all data from another property to this one. Child properties are copied by reference,\n\t * unless a 'resolve' function is given to override that.\n\t * @param other Property to copy references from.\n\t * @param resolve Function to resolve each Property being transferred. Default is identity.\n\t */\n\tpublic copy(other: this, resolve: PropertyResolver<Property> = COPY_IDENTITY): this {\n\t\t// Remove previous references.\n\t\tfor (const key in this[$attributes]) {\n\t\t\tconst value = this[$attributes][key];\n\t\t\tif (value instanceof GraphEdge) {\n\t\t\t\tif (!this[$immutableKeys].has(key)) {\n\t\t\t\t\tvalue.dispose();\n\t\t\t\t}\n\t\t\t} else if (Array.isArray(value) && value[0] instanceof GraphEdge) {\n\t\t\t\tfor (const ref of value as Ref[]) {\n\t\t\t\t\tref.dispose();\n\t\t\t\t}\n\t\t\t} else if (isPlainObject(value) && Object.values(value)[0] instanceof GraphEdge) {\n\t\t\t\tfor (const subkey in value) {\n\t\t\t\t\tconst ref = value[subkey] as Ref;\n\t\t\t\t\tref.dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add new references.\n\t\tfor (const key in other[$attributes]) {\n\t\t\tconst thisValue = this[$attributes][key];\n\t\t\tconst otherValue = other[$attributes][key];\n\t\t\tif (otherValue instanceof GraphEdge) {\n\t\t\t\tif (this[$immutableKeys].has(key)) {\n\t\t\t\t\tconst ref = thisValue as unknown as Ref;\n\t\t\t\t\tref.getChild().copy(resolve(otherValue.getChild()), resolve);\n\t\t\t\t} else {\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\t\t\tthis.setRef(key as any, resolve(otherValue.getChild()), otherValue.getAttributes());\n\t\t\t\t}\n\t\t\t} else if (Array.isArray(otherValue) && otherValue[0] instanceof GraphEdge) {\n\t\t\t\tfor (const ref of otherValue as Ref[]) {\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\t\t\tthis.addRef(key as any, resolve(ref.getChild()), ref.getAttributes());\n\t\t\t\t}\n\t\t\t} else if (isPlainObject(otherValue) && Object.values(otherValue)[0] instanceof GraphEdge) {\n\t\t\t\tfor (const subkey in otherValue) {\n\t\t\t\t\tconst ref = otherValue[subkey] as Ref;\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\t\t\tthis.setRefMap(key as any, subkey, resolve(ref.getChild()), ref.getAttributes());\n\t\t\t\t}\n\t\t\t} else if (isPlainObject(otherValue)) {\n\t\t\t\tthis[$attributes][key] = JSON.parse(JSON.stringify(otherValue));\n\t\t\t} else if (\n\t\t\t\tArray.isArray(otherValue) ||\n\t\t\t\totherValue instanceof ArrayBuffer ||\n\t\t\t\tArrayBuffer.isView(otherValue)\n\t\t\t) {\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\t\tthis[$attributes][key] = (otherValue as unknown as Uint8Array).slice() as any;\n\t\t\t} else {\n\t\t\t\tthis[$attributes][key] = otherValue;\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns true if two properties are deeply equivalent, recursively comparing the attributes\n\t * of the properties. For example, two {@link Primitive Primitives} are equivalent if they\n\t * have accessors and materials with equivalent content — but not necessarily the same specific\n\t * accessors and materials.\n\t */\n\tpublic equals(other: this): boolean {\n\t\tif (this === other) return true;\n\t\tif (this.propertyType !== other.propertyType) return false;\n\n\t\tfor (const key in this[$attributes]) {\n\t\t\tconst a = this[$attributes][key] as UnknownRef;\n\t\t\tconst b = other[$attributes][key] as UnknownRef;\n\n\t\t\tif (isRef(a) || isRef(b)) {\n\t\t\t\tif (!equalsRef(a as Ref, b as Ref)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else if (isRefList(a) || isRefList(b)) {\n\t\t\t\tif (!equalsRefList(a as Ref[], b as Ref[])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else if (isRefMap(a) || isRefMap(b)) {\n\t\t\t\tif (!equalsRefMap(a as RefMap, b as RefMap)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else if (isPlainObject(a) || isPlainObject(b)) {\n\t\t\t\tif (!equalsObject(a, b)) return false;\n\t\t\t} else if (isArray(a) || isArray(b)) {\n\t\t\t\tif (!equalsArray(a as [], b as [])) return false;\n\t\t\t} else {\n\t\t\t\t// Literal.\n\t\t\t\tif (a !== b) return false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic detach(): this {\n\t\t// Detaching should keep properties in the same Document, and attached to its root.\n\t\tthis.graph.disconnectParents(this, (n: Property) => n.propertyType !== 'Root');\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns a list of all properties that hold a reference to this property. For example, a\n\t * material may hold references to various textures, but a texture does not hold references\n\t * to the materials that use it.\n\t *\n\t * It is often necessary to filter the results for a particular type: some resources, like\n\t * {@link Accessor}s, may be referenced by different types of properties. Most properties\n\t * include the {@link Root} as a parent, which is usually not of interest.\n\t *\n\t * Usage:\n\t *\n\t * ```ts\n\t * const materials = texture\n\t * \t.listParents()\n\t * \t.filter((p) => p instanceof Material)\n\t * ```\n\t */\n\tpublic listParents(): Property[] {\n\t\treturn this.graph.listParents(this);\n\t}\n}\n","import { Nullable } from '../constants';\nimport { ExtensionProperty } from './extension-property';\nimport { Property, IProperty } from './property';\n\nexport interface IExtensibleProperty extends IProperty {\n\textensions: { [key: string]: ExtensionProperty };\n}\n\n/**\n * # ExtensibleProperty\n *\n * *A {@link Property} that can have {@link ExtensionProperty} instances attached.*\n *\n * Most properties are extensible. See the {@link Extension} documentation for information about\n * how to use extensions.\n *\n * @category Properties\n */\nexport abstract class ExtensibleProperty<T extends IExtensibleProperty = IExtensibleProperty> extends Property<T> {\n\tprotected getDefaults(): Nullable<T> {\n\t\treturn Object.assign(super.getDefaults(), { extensions: {} });\n\t}\n\n\t/** Returns an {@link ExtensionProperty} attached to this Property, if any. */\n\tpublic getExtension<Prop extends ExtensionProperty>(name: string): Prop | null {\n\t\treturn (this as ExtensibleProperty).getRefMap('extensions', name) as Prop;\n\t}\n\n\t/**\n\t * Attaches the given {@link ExtensionProperty} to this Property. For a given extension, only\n\t * one ExtensionProperty may be attached to any one Property at a time.\n\t */\n\tpublic setExtension<Prop extends ExtensionProperty>(name: string, extensionProperty: Prop | null): this {\n\t\tif (extensionProperty) extensionProperty._validateParent(this as ExtensibleProperty);\n\t\treturn (this as ExtensibleProperty).setRefMap('extensions', name, extensionProperty) as this;\n\t}\n\n\t/** Lists all {@link ExtensionProperty} instances attached to this Property. */\n\tpublic listExtensions(): ExtensionProperty[] {\n\t\treturn (this as ExtensibleProperty).listRefMapValues('extensions');\n\t}\n}\n","import { Nullable, PropertyType, TypedArray } from '../constants';\nimport { GLTF } from '../types/gltf';\nimport { MathUtils } from '../utils';\nimport { Buffer } from './buffer';\nimport { ExtensibleProperty, IExtensibleProperty } from './extensible-property';\nimport { COPY_IDENTITY } from './property';\n\ninterface IAccessor extends IExtensibleProperty {\n\tarray: TypedArray | null;\n\ttype: GLTF.AccessorType;\n\tcomponentType: GLTF.AccessorComponentType;\n\tnormalized: boolean;\n\tbuffer: Buffer;\n}\n\n/**\n * # Accessor\n *\n * *Accessors store lists of numeric, vector, or matrix elements in a typed array.*\n *\n * All large data for {@link Mesh}, {@link Skin}, and {@link Animation} properties is stored in\n * {@link Accessor}s, organized into one or more {@link Buffer}s. Each accessor provides data in\n * typed arrays, with two abstractions:\n *\n * *Elements* are the logical divisions of the data into useful types: `\"SCALAR\"`, `\"VEC2\"`,\n * `\"VEC3\"`, `\"VEC4\"`, `\"MAT3\"`, or `\"MAT4\"`. The element type can be determined with the\n * {@link getType}() method, and the number of elements in the accessor determine its\n * {@link getCount}(). The number of components in an element — e.g. 9 for `\"MAT3\"` — are its\n * {@link getElementSize}(). See {@link Accessor.Type}.\n *\n * *Components* are the numeric values within an element — e.g. `.x` and `.y` for `\"VEC2\"`. Various\n * component types are available: `BYTE`, `UNSIGNED_BYTE`, `SHORT`, `UNSIGNED_SHORT`,\n * `UNSIGNED_INT`, and `FLOAT`. The component type can be determined with the\n * {@link getComponentType} method, and the number of bytes in each component determine its\n * {@link getComponentSize}. See {@link Accessor.ComponentType}.\n *\n * Usage:\n *\n * ```typescript\n * const accessor = doc.createAccessor('myData')\n * \t.setArray(new Float32Array([1,2,3,4,5,6,7,8,9,10,11,12]))\n * \t.setType(Accessor.Type.VEC3)\n * \t.setBuffer(doc.listBuffers()[0]);\n *\n * accessor.getCount();        // → 4\n * accessor.getElementSize();  // → 3\n * accessor.getByteLength();   // → 48\n * accessor.getElement(1, []); // → [4, 5, 6]\n *\n * accessor.setElement(0, [10, 20, 30]);\n * ```\n *\n * Data access through the {@link getElement} and {@link setElement} methods reads or overwrites\n * the content of the underlying typed array. These methods use element arrays intended to be\n * compatible with the [gl-matrix](https://github.com/toji/gl-matrix) library, or with the\n * `toArray`/`fromArray` methods of libraries like three.js and babylon.js.\n *\n * Each Accessor must be assigned to a {@link Buffer}, which determines where the accessor's data\n * is stored in the final file. Assigning Accessors to different Buffers allows the data to be\n * written to different `.bin` files.\n *\n * glTF-Transform does not expose many details of sparse, normalized, or interleaved accessors\n * through its API. It reads files using those techniques, presents a simplified view of the data\n * for editing, and attempts to write data back out with optimizations. For example, vertex\n * attributes will typically be interleaved by default, regardless of the input file.\n *\n * References:\n * - [glTF → Accessors](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors)\n *\n * @category Properties\n */\nexport class Accessor extends ExtensibleProperty<IAccessor> {\n\tpublic declare propertyType: PropertyType.ACCESSOR;\n\n\t/**********************************************************************************************\n\t * Constants.\n\t */\n\n\t/** Element type contained by the accessor (SCALAR, VEC2, ...). */\n\tpublic static Type: Record<string, GLTF.AccessorType> = {\n\t\t/** Scalar, having 1 value per element. */\n\t\tSCALAR: 'SCALAR',\n\t\t/** 2-component vector, having 2 components per element. */\n\t\tVEC2: 'VEC2',\n\t\t/** 3-component vector, having 3 components per element. */\n\t\tVEC3: 'VEC3',\n\t\t/** 4-component vector, having 4 components per element. */\n\t\tVEC4: 'VEC4',\n\t\t/** 2x2 matrix, having 4 components per element. */\n\t\tMAT2: 'MAT2',\n\t\t/** 3x3 matrix, having 9 components per element. */\n\t\tMAT3: 'MAT3',\n\t\t/** 4x3 matrix, having 16 components per element. */\n\t\tMAT4: 'MAT4',\n\t};\n\n\t/** Data type of the values composing each element in the accessor. */\n\tpublic static ComponentType: Record<string, GLTF.AccessorComponentType> = {\n\t\t/**\n\t\t * 1-byte signed integer, stored as\n\t\t * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array Int8Array}.\n\t\t */\n\t\tBYTE: 5120,\n\t\t/**\n\t\t * 1-byte unsigned integer, stored as\n\t\t * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array Uint8Array}.\n\t\t */\n\t\tUNSIGNED_BYTE: 5121,\n\t\t/**\n\t\t * 2-byte signed integer, stored as\n\t\t * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array Uint16Array}.\n\t\t */\n\t\tSHORT: 5122,\n\t\t/**\n\t\t * 2-byte unsigned integer, stored as\n\t\t * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array Uint16Array}.\n\t\t */\n\t\tUNSIGNED_SHORT: 5123,\n\t\t/**\n\t\t * 4-byte unsigned integer, stored as\n\t\t * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array Uint32Array}.\n\t\t */\n\t\tUNSIGNED_INT: 5125,\n\t\t/**\n\t\t * 4-byte floating point number, stored as\n\t\t * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array Float32Array}.\n\t\t */\n\t\tFLOAT: 5126,\n\t};\n\n\t/**********************************************************************************************\n\t * Instance.\n\t */\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.ACCESSOR;\n\t}\n\n\tprotected getDefaults(): Nullable<IAccessor> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\tarray: null,\n\t\t\ttype: Accessor.Type.SCALAR,\n\t\t\tcomponentType: Accessor.ComponentType.FLOAT,\n\t\t\tnormalized: false,\n\t\t\tbuffer: null,\n\t\t});\n\t}\n\n\t/** @internal Inbound transform to normalized representation, if applicable. */\n\tprivate _in = MathUtils.identity;\n\n\t/** @internal Outbound transform from normalized representation, if applicable. */\n\tprivate _out = MathUtils.identity;\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\t\tthis._in = other._in;\n\t\tthis._out = other._out;\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Static.\n\t */\n\n\t/** Returns size of a given element type, in components. */\n\tpublic static getElementSize(type: GLTF.AccessorType): number {\n\t\tswitch (type) {\n\t\t\tcase Accessor.Type.SCALAR:\n\t\t\t\treturn 1;\n\t\t\tcase Accessor.Type.VEC2:\n\t\t\t\treturn 2;\n\t\t\tcase Accessor.Type.VEC3:\n\t\t\t\treturn 3;\n\t\t\tcase Accessor.Type.VEC4:\n\t\t\t\treturn 4;\n\t\t\tcase Accessor.Type.MAT2:\n\t\t\t\treturn 4;\n\t\t\tcase Accessor.Type.MAT3:\n\t\t\t\treturn 9;\n\t\t\tcase Accessor.Type.MAT4:\n\t\t\t\treturn 16;\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unexpected type: ' + type);\n\t\t}\n\t}\n\n\t/** Returns size of a given component type, in bytes. */\n\tpublic static getComponentSize(componentType: GLTF.AccessorComponentType): number {\n\t\tswitch (componentType) {\n\t\t\tcase Accessor.ComponentType.BYTE:\n\t\t\t\treturn 1;\n\t\t\tcase Accessor.ComponentType.UNSIGNED_BYTE:\n\t\t\t\treturn 1;\n\t\t\tcase Accessor.ComponentType.SHORT:\n\t\t\t\treturn 2;\n\t\t\tcase Accessor.ComponentType.UNSIGNED_SHORT:\n\t\t\t\treturn 2;\n\t\t\tcase Accessor.ComponentType.UNSIGNED_INT:\n\t\t\t\treturn 4;\n\t\t\tcase Accessor.ComponentType.FLOAT:\n\t\t\t\treturn 4;\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unexpected component type: ' + componentType);\n\t\t}\n\t}\n\n\t/**********************************************************************************************\n\t * Min/max bounds.\n\t */\n\n\t/**\n\t * Minimum value of each component in this attribute. Unlike in a final glTF file, values\n\t * returned by this method will reflect the minimum accounting for {@link .normalized}\n\t * state.\n\t */\n\tpublic getMinNormalized(target: number[]): number[] {\n\t\tconst elementSize = this.getElementSize();\n\n\t\tthis.getMin(target);\n\n\t\tfor (let j = 0; j < elementSize; j++) target[j] = this._out(target[j]);\n\n\t\treturn target;\n\t}\n\n\t/**\n\t * Minimum value of each component in this attribute. Values returned by this method do not\n\t * reflect normalization: use {@link .getMinNormalized} in that case.\n\t */\n\tpublic getMin(target: number[]): number[] {\n\t\tconst array = this.get('array');\n\t\tconst count = this.getCount();\n\t\tconst elementSize = this.getElementSize();\n\n\t\tfor (let j = 0; j < elementSize; j++) target[j] = Infinity;\n\n\t\tfor (let i = 0; i < count * elementSize; i += elementSize) {\n\t\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\t\tconst value = array![i + j];\n\t\t\t\tif (Number.isFinite(value)) {\n\t\t\t\t\ttarget[j] = Math.min(target[j], value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn target;\n\t}\n\n\t/**\n\t * Maximum value of each component in this attribute. Unlike in a final glTF file, values\n\t * returned by this method will reflect the minimum accounting for {@link .normalized}\n\t * state.\n\t */\n\tpublic getMaxNormalized(target: number[]): number[] {\n\t\tconst elementSize = this.getElementSize();\n\n\t\tthis.getMax(target);\n\n\t\tfor (let j = 0; j < elementSize; j++) target[j] = this._out(target[j]);\n\n\t\treturn target;\n\t}\n\n\t/**\n\t * Maximum value of each component in this attribute. Values returned by this method do not\n\t * reflect normalization: use {@link .getMinNormalized} in that case.\n\t */\n\tpublic getMax(target: number[]): number[] {\n\t\tconst array = this.get('array');\n\t\tconst count = this.getCount();\n\t\tconst elementSize = this.getElementSize();\n\n\t\tfor (let j = 0; j < elementSize; j++) target[j] = -Infinity;\n\n\t\tfor (let i = 0; i < count * elementSize; i += elementSize) {\n\t\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\t\tconst value = array![i + j];\n\t\t\t\tif (Number.isFinite(value)) {\n\t\t\t\t\ttarget[j] = Math.max(target[j], value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn target;\n\t}\n\n\t/**********************************************************************************************\n\t * Layout.\n\t */\n\n\t/**\n\t * Number of elements in the accessor. An array of length 30, containing 10 `VEC3` elements,\n\t * will have a count of 10.\n\t */\n\tpublic getCount(): number {\n\t\tconst array = this.get('array');\n\t\treturn array ? array.length / this.getElementSize() : 0;\n\t}\n\n\t/** Type of element stored in the accessor. `VEC2`, `VEC3`, etc. */\n\tpublic getType(): GLTF.AccessorType {\n\t\treturn this.get('type');\n\t}\n\n\t/**\n\t * Sets type of element stored in the accessor. `VEC2`, `VEC3`, etc. Array length must be a\n\t * multiple of the component size (`VEC2` = 2, `VEC3` = 3, ...) for the selected type.\n\t */\n\tpublic setType(type: GLTF.AccessorType): Accessor {\n\t\treturn this.set('type', type);\n\t}\n\n\t/**\n\t * Number of components in each element of the accessor. For example, the element size of a\n\t * `VEC2` accessor is 2. This value is determined automatically based on array length and\n\t * accessor type, specified with {@link setType}().\n\t */\n\tpublic getElementSize(): number {\n\t\treturn Accessor.getElementSize(this.get('type'));\n\t}\n\n\t/**\n\t * Size of each component (a value in the raw array), in bytes. For example, the\n\t * `componentSize` of data backed by a `float32` array is 4 bytes.\n\t */\n\tpublic getComponentSize(): number {\n\t\treturn this.get('array')!.BYTES_PER_ELEMENT;\n\t}\n\n\t/**\n\t * Component type (float32, uint16, etc.). This value is determined automatically, and can only\n\t * be modified by replacing the underlying array.\n\t */\n\tpublic getComponentType(): GLTF.AccessorComponentType {\n\t\treturn this.get('componentType');\n\t}\n\n\t/**********************************************************************************************\n\t * Normalization.\n\t */\n\n\t/**\n\t * Specifies whether integer data values should be normalized (true) to [0, 1] (for unsigned\n\t * types) or [-1, 1] (for signed types), or converted directly (false) when they are accessed.\n\t * This property is defined only for accessors that contain vertex attributes or animation\n\t * output data.\n\t */\n\tpublic getNormalized(): boolean {\n\t\treturn this.get('normalized');\n\t}\n\n\t/**\n\t * Specifies whether integer data values should be normalized (true) to [0, 1] (for unsigned\n\t * types) or [-1, 1] (for signed types), or converted directly (false) when they are accessed.\n\t * This property is defined only for accessors that contain vertex attributes or animation\n\t * output data.\n\t */\n\tpublic setNormalized(normalized: boolean): this {\n\t\tthis.set('normalized', normalized);\n\n\t\tif (normalized) {\n\t\t\tthis._out = (c: number): number => MathUtils.denormalize(c, this.get('componentType'));\n\t\t\tthis._in = (f: number): number => MathUtils.normalize(f, this.get('componentType'));\n\t\t} else {\n\t\t\tthis._out = MathUtils.identity;\n\t\t\tthis._in = MathUtils.identity;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Data access.\n\t */\n\n\t/**\n\t * Returns the scalar element value at the given index, accounting for normalization if\n\t * applicable.\n\t */\n\tpublic getScalar(index: number): number {\n\t\tconst elementSize = this.getElementSize();\n\t\treturn this._out(this.get('array')![index * elementSize]);\n\t}\n\n\t/**\n\t * Assigns the scalar element value at the given index, accounting for normalization if\n\t * applicable.\n\t */\n\tpublic setScalar(index: number, x: number): this {\n\t\tthis.get('array')![index * this.getElementSize()] = this._in(x);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the vector or matrix element value at the given index, accounting for normalization\n\t * if applicable.\n\t */\n\tpublic getElement(index: number, target: number[]): number[] {\n\t\tconst elementSize = this.getElementSize();\n\t\tconst array = this.get('array')!;\n\t\tfor (let i = 0; i < elementSize; i++) {\n\t\t\ttarget[i] = this._out(array[index * elementSize + i]);\n\t\t}\n\t\treturn target;\n\t}\n\n\t/**\n\t * Assigns the vector or matrix element value at the given index, accounting for normalization\n\t * if applicable.\n\t */\n\tpublic setElement(index: number, value: number[]): this {\n\t\tconst elementSize = this.getElementSize();\n\t\tconst array = this.get('array')!;\n\t\tfor (let i = 0; i < elementSize; i++) {\n\t\t\tarray![index * elementSize + i] = this._in(value[i]);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Raw data storage.\n\t */\n\n\t/** Returns the {@link Buffer} into which this accessor will be organized. */\n\tpublic getBuffer(): Buffer | null {\n\t\treturn this.getRef('buffer');\n\t}\n\n\t/** Assigns the {@link Buffer} into which this accessor will be organized. */\n\tpublic setBuffer(buffer: Buffer | null): this {\n\t\treturn this.setRef('buffer', buffer);\n\t}\n\n\t/** Returns the raw typed array underlying this accessor. */\n\tpublic getArray(): TypedArray | null {\n\t\treturn this.get('array');\n\t}\n\n\t/** Assigns the raw typed array underlying this accessor. */\n\tpublic setArray(array: TypedArray): this {\n\t\tthis.set('componentType', array ? arrayToComponentType(array) : Accessor.ComponentType.FLOAT);\n\t\tthis.set('array', array);\n\t\treturn this;\n\t}\n\n\t/** Returns the total bytelength of this accessor, exclusive of padding. */\n\tpublic getByteLength(): number {\n\t\tconst array = this.get('array');\n\t\treturn array ? array.byteLength : 0;\n\t}\n}\n\n/**************************************************************************************************\n * Accessor utilities.\n */\n\n/** @internal */\nfunction arrayToComponentType(array: TypedArray): GLTF.AccessorComponentType {\n\tswitch (array.constructor) {\n\t\tcase Float32Array:\n\t\t\treturn Accessor.ComponentType.FLOAT;\n\t\tcase Uint32Array:\n\t\t\treturn Accessor.ComponentType.UNSIGNED_INT;\n\t\tcase Uint16Array:\n\t\t\treturn Accessor.ComponentType.UNSIGNED_SHORT;\n\t\tcase Uint8Array:\n\t\t\treturn Accessor.ComponentType.UNSIGNED_BYTE;\n\t\tcase Int16Array:\n\t\t\treturn Accessor.ComponentType.SHORT;\n\t\tcase Int8Array:\n\t\t\treturn Accessor.ComponentType.BYTE;\n\t\tdefault:\n\t\t\tthrow new Error('Unknown accessor componentType.');\n\t}\n}\n","import { Nullable, PropertyType } from '../constants';\nimport { AnimationChannel } from './animation-channel';\nimport { AnimationSampler } from './animation-sampler';\nimport { ExtensibleProperty, IExtensibleProperty } from './extensible-property';\n\ninterface IAnimation extends IExtensibleProperty {\n\tchannels: AnimationChannel[];\n\tsamplers: AnimationSampler[];\n}\n\n/**\n * # Animation\n *\n * *Reusable collections of {@link AnimationChannel}s, together representing a discrete animation\n * clip.*\n *\n * One Animation represents one playable unit in an animation system. Each may contain channels\n * affecting multiple paths (`translation`, `rotation`, `scale`, or `weights`) on multiple\n * {@link Node}s. An Animation's channels must be played together, and do not have any meaning in\n * isolation.\n *\n * Multiple Animations _may_ be played together: for example, one character's _Walk_ animation\n * might play while another character's _Run_ animation plays. Or a single character might have\n * both an _Idle_ and a _Talk_ animation playing at the same time. However, glTF does not define\n * any particular relationship between top-level Animations, or any particular playback behavior\n * like looping or sequences of Animations. General-purpose viewers typically autoplay the first\n * animation and provide UI controls for choosing another. Game engines may have significantly\n * more advanced methods of playing and blending animations.\n *\n * For example, a very simple skinned {@link Mesh} might have two Animations, _Idle_ and _Walk_.\n * Each of those Animations might affect the rotations of two bones, _LegL_ and _LegR_, where the\n * keyframes for each target-path pair are stored in {@link AnimationChannel} instances. In  total,\n * this model would contain two Animations and Four {@link AnimationChannel}s.\n *\n * Usage:\n *\n * ```ts\n * const animation = doc.createAnimation('machineRun')\n * \t.addChannel(rotateCog1)\n * \t.addChannel(rotateCog2)\n * \t.addChannel(rotateCog3);\n * ```\n *\n * Reference\n * - [glTF → Animations](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#animations)\n */\nexport class Animation extends ExtensibleProperty<IAnimation> {\n\tpublic declare propertyType: PropertyType.ANIMATION;\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.ANIMATION;\n\t}\n\n\tprotected getDefaults(): Nullable<IAnimation> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, { channels: [], samplers: [] });\n\t}\n\n\t/** Adds an {@link AnimationChannel} to this Animation. */\n\tpublic addChannel(channel: AnimationChannel): this {\n\t\treturn this.addRef('channels', channel);\n\t}\n\n\t/** Removes an {@link AnimationChannel} from this Animation. */\n\tpublic removeChannel(channel: AnimationChannel): this {\n\t\treturn this.removeRef('channels', channel);\n\t}\n\n\t/** Lists {@link AnimationChannel}s in this Animation. */\n\tpublic listChannels(): AnimationChannel[] {\n\t\treturn this.listRefs('channels');\n\t}\n\n\t/** Adds an {@link AnimationSampler} to this Animation. */\n\tpublic addSampler(sampler: AnimationSampler): this {\n\t\treturn this.addRef('samplers', sampler);\n\t}\n\n\t/** Removes an {@link AnimationSampler} from this Animation. */\n\tpublic removeSampler(sampler: AnimationSampler): this {\n\t\treturn this.removeRef('samplers', sampler);\n\t}\n\n\t/** Lists {@link AnimationSampler}s in this Animation. */\n\tpublic listSamplers(): AnimationSampler[] {\n\t\treturn this.listRefs('samplers');\n\t}\n}\n","import { Nullable, PropertyType } from '../constants';\nimport { GLTF } from '../types/gltf';\nimport { AnimationSampler } from './animation-sampler';\nimport { ExtensibleProperty, IExtensibleProperty } from './extensible-property';\nimport { Node } from './node';\n\ninterface IAnimationChannel extends IExtensibleProperty {\n\ttargetPath: GLTF.AnimationChannelTargetPath | null;\n\ttargetNode: Node;\n\tsampler: AnimationSampler;\n}\n\n/**\n * # AnimationChannel\n *\n * *A target-path pair within a larger {@link Animation}, which refers to an\n * {@link AnimationSampler} storing the keyframe data for that pair.*\n *\n * A _target_ is always a {@link Node}, in the core glTF spec. A _path_ is any property of that\n * Node that can be affected by animation: `translation`, `rotation`, `scale`, or `weights`. An\n * {@link Animation} affecting the positions and rotations of several {@link Node}s would contain\n * one channel for each Node-position or Node-rotation pair. The keyframe data for an\n * AnimationChannel is stored in an {@link AnimationSampler}, which must be attached to the same\n * {@link Animation}.\n *\n * Usage:\n *\n * ```ts\n * const node = doc.getRoot()\n * \t.listNodes()\n * \t.find((node) => node.getName() === 'Cog');\n *\n * const channel = doc.createAnimationChannel('cogRotation')\n * \t.setTargetPath('rotation')\n * \t.setTargetNode(node)\n * \t.setSampler(rotateSampler);\n * ```\n *\n * Reference\n * - [glTF → Animations](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#animations)\n */\nexport class AnimationChannel extends ExtensibleProperty<IAnimationChannel> {\n\tpublic declare propertyType: PropertyType.ANIMATION_CHANNEL;\n\n\t/**********************************************************************************************\n\t * Constants.\n\t */\n\n\t/** Name of the property to be modified by an animation channel. */\n\tpublic static TargetPath: Record<string, GLTF.AnimationChannelTargetPath> = {\n\t\t/** Channel targets {@link Node.setTranslation}. */\n\t\tTRANSLATION: 'translation',\n\t\t/** Channel targets {@link Node.setRotation}. */\n\t\tROTATION: 'rotation',\n\t\t/** Channel targets {@link Node.setScale}. */\n\t\tSCALE: 'scale',\n\t\t/** Channel targets {@link Node.setWeights}, affecting {@link PrimitiveTarget} weights. */\n\t\tWEIGHTS: 'weights',\n\t};\n\n\t/**********************************************************************************************\n\t * Instance.\n\t */\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.ANIMATION_CHANNEL;\n\t}\n\n\tprotected getDefaults(): Nullable<IAnimationChannel> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\ttargetPath: null,\n\t\t\ttargetNode: null,\n\t\t\tsampler: null,\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Properties.\n\t */\n\n\t/**\n\t * Path (property) animated on the target {@link Node}. Supported values include:\n\t * `translation`, `rotation`, `scale`, or `weights`.\n\t */\n\tpublic getTargetPath(): GLTF.AnimationChannelTargetPath | null {\n\t\treturn this.get('targetPath');\n\t}\n\n\t/**\n\t * Path (property) animated on the target {@link Node}. Supported values include:\n\t * `translation`, `rotation`, `scale`, or `weights`.\n\t */\n\tpublic setTargetPath(targetPath: GLTF.AnimationChannelTargetPath): this {\n\t\treturn this.set('targetPath', targetPath);\n\t}\n\n\t/** Target {@link Node} animated by the channel. */\n\tpublic getTargetNode(): Node | null {\n\t\treturn this.getRef('targetNode');\n\t}\n\n\t/** Target {@link Node} animated by the channel. */\n\tpublic setTargetNode(targetNode: Node | null): this {\n\t\treturn this.setRef('targetNode', targetNode);\n\t}\n\n\t/**\n\t * Keyframe data input/output values for the channel. Must be attached to the same\n\t * {@link Animation}.\n\t */\n\tpublic getSampler(): AnimationSampler | null {\n\t\treturn this.getRef('sampler');\n\t}\n\n\t/**\n\t * Keyframe data input/output values for the channel. Must be attached to the same\n\t * {@link Animation}.\n\t */\n\tpublic setSampler(sampler: AnimationSampler | null): this {\n\t\treturn this.setRef('sampler', sampler);\n\t}\n}\n","import { BufferViewUsage, Nullable, PropertyType } from '../constants';\nimport { GLTF } from '../types/gltf';\nimport { Accessor } from './accessor';\nimport { ExtensibleProperty, IExtensibleProperty } from './extensible-property';\n\ninterface IAnimationSampler extends IExtensibleProperty {\n\tinterpolation: GLTF.AnimationSamplerInterpolation;\n\tinput: Accessor;\n\toutput: Accessor;\n}\n\n/**\n * # AnimationSampler\n *\n * *Reusable collection of keyframes affecting particular property of an object.*\n *\n * Each AnimationSampler refers to an input and an output {@link Accessor}. Input contains times\n * (in seconds) for each keyframe. Output contains values (of any {@link Accessor.Type}) for the\n * animated property at each keyframe. Samplers using `CUBICSPLINE` interpolation will also contain\n * in/out tangents in the output, with the layout:\n *\n * in<sub>1</sub>, value<sub>1</sub>, out<sub>1</sub>,\n * in<sub>2</sub>, value<sub>2</sub>, out<sub>2</sub>,\n * in<sub>3</sub>, value<sub>3</sub>, out<sub>3</sub>, ...\n *\n * Usage:\n *\n * ```ts\n * // Create accessor containing input times, in seconds.\n * const input = doc.createAccessor('bounceTimes')\n * \t.setArray(new Float32Array([0, 1, 2]))\n * \t.setType(Accessor.Type.SCALAR);\n *\n * // Create accessor containing output values, in local units.\n * const output = doc.createAccessor('bounceValues')\n * \t.setArray(new Float32Array([\n * \t\t0, 0, 0, // y = 0\n * \t\t0, 1, 0, // y = 1\n * \t\t0, 0, 0, // y = 0\n * \t]))\n * \t.setType(Accessor.Type.VEC3);\n *\n * // Create sampler.\n * const sampler = doc.createAnimationSampler('bounce')\n * \t.setInput(input)\n * \t.setOutput(output)\n * \t.setInterpolation('LINEAR');\n * ```\n *\n * Reference\n * - [glTF → Animations](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#animations)\n */\nexport class AnimationSampler extends ExtensibleProperty<IAnimationSampler> {\n\tpublic declare propertyType: PropertyType.ANIMATION_SAMPLER;\n\n\t/**********************************************************************************************\n\t * Constants.\n\t */\n\n\t/** Interpolation method. */\n\tpublic static Interpolation: Record<string, GLTF.AnimationSamplerInterpolation> = {\n\t\t/** Animated values are linearly interpolated between keyframes. */\n\t\tLINEAR: 'LINEAR',\n\t\t/** Animated values remain constant from one keyframe until the next keyframe. */\n\t\tSTEP: 'STEP',\n\t\t/** Animated values are interpolated according to given cubic spline tangents. */\n\t\tCUBICSPLINE: 'CUBICSPLINE',\n\t};\n\n\t/**********************************************************************************************\n\t * Instance.\n\t */\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.ANIMATION_SAMPLER;\n\t}\n\n\tprotected getDefaultAttributes(): Nullable<IAnimationSampler> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\tinterpolation: AnimationSampler.Interpolation.LINEAR,\n\t\t\tinput: null,\n\t\t\toutput: null,\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Static.\n\t */\n\n\t/** Interpolation mode: `STEP`, `LINEAR`, or `CUBICSPLINE`. */\n\tpublic getInterpolation(): GLTF.AnimationSamplerInterpolation {\n\t\treturn this.get('interpolation');\n\t}\n\n\t/** Interpolation mode: `STEP`, `LINEAR`, or `CUBICSPLINE`. */\n\tpublic setInterpolation(interpolation: GLTF.AnimationSamplerInterpolation): this {\n\t\treturn this.set('interpolation', interpolation);\n\t}\n\n\t/** Times for each keyframe, in seconds. */\n\tpublic getInput(): Accessor | null {\n\t\treturn this.getRef('input');\n\t}\n\n\t/** Times for each keyframe, in seconds. */\n\tpublic setInput(input: Accessor | null): this {\n\t\treturn this.setRef('input', input, { usage: BufferViewUsage.OTHER });\n\t}\n\n\t/**\n\t * Values for each keyframe. For `CUBICSPLINE` interpolation, output also contains in/out\n\t * tangents.\n\t */\n\tpublic getOutput(): Accessor | null {\n\t\treturn this.getRef('output');\n\t}\n\n\t/**\n\t * Values for each keyframe. For `CUBICSPLINE` interpolation, output also contains in/out\n\t * tangents.\n\t */\n\tpublic setOutput(output: Accessor | null): this {\n\t\treturn this.setRef('output', output, { usage: BufferViewUsage.OTHER });\n\t}\n}\n","import { Nullable, PropertyType } from '../constants';\nimport { ExtensibleProperty, IExtensibleProperty } from './extensible-property';\n\ninterface IBuffer extends IExtensibleProperty {\n\turi: string;\n}\n\n/**\n * # Buffer\n *\n * *Buffers are low-level storage units for binary data.*\n *\n * glTF 2.0 has three concepts relevant to binary storage: accessors, buffer views, and buffers.\n * In glTF-Transform, an {@link Accessor} is referenced by any property that requires numeric typed\n * array data. Meshes, Primitives, and Animations all reference Accessors. Buffers define how that\n * data is organized into transmitted file(s). A `.glb` file has only a single Buffer, and when\n * exporting to `.glb` your resources should be grouped accordingly. A `.gltf` file may reference\n * one or more `.bin` files — each `.bin` is a Buffer — and grouping Accessors under different\n * Buffers allow you to specify that structure.\n *\n * For engines that can dynamically load portions of a glTF file, splitting data into separate\n * buffers can allow you to avoid loading data until it is needed. For example, you might put\n * binary data for specific meshes into a different `.bin` buffer, or put each animation's binary\n * payload into its own `.bin`.\n *\n * Buffer Views define how Accessors are organized within a given Buffer. glTF-Transform creates an\n * efficient Buffer View layout automatically at export: there is no Buffer View property exposed\n * by the glTF-Transform API, simplifying data management.\n *\n * Usage:\n *\n * ```ts\n * // Create two buffers with custom filenames.\n * const buffer1 = doc.createBuffer('buffer1')\n * \t.setURI('part1.bin');\n * const buffer2 = doc.createBuffer('buffer2')\n * \t.setURI('part2.bin');\n *\n * // Assign the attributes of two meshes to different buffers. If the meshes\n * // had indices or morph target attributes, you would also want to relocate\n * // those accessors.\n * mesh1\n * \t.listPrimitives()\n * \t.forEach((primitive) => primitive.listAttributes()\n * \t\t.forEach((attribute) => attribute.setBuffer(buffer1)));\n * mesh2\n * \t.listPrimitives()\n * \t.forEach((primitive) => primitive.listAttributes()\n * \t\t.forEach((attribute) => attribute.setBuffer(buffer2)));\n *\n * // Write to disk. Each mesh's binary data will be in a separate binary file;\n * // any remaining accessors will be in a third (default) buffer.\n * await new NodeIO().write('scene.gltf', doc);\n * // → scene.gltf, part1.bin, part2.bin\n * ```\n *\n * References:\n * - [glTF → Buffers and Buffer Views](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views)\n * - [glTF → Accessors](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors)\n *\n * @category Properties\n */\nexport class Buffer extends ExtensibleProperty<IBuffer> {\n\tpublic declare propertyType: PropertyType.BUFFER;\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.BUFFER;\n\t}\n\n\tprotected getDefaults(): Nullable<IBuffer> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, { uri: '' });\n\t}\n\n\t/**\n\t * Returns the URI (or filename) of this buffer (e.g. 'myBuffer.bin'). URIs are strongly\n\t * encouraged to be relative paths, rather than absolute. Use of a protocol (like `file://`)\n\t * is possible for custom applications, but will limit the compatibility of the asset with most\n\t * tools.\n\t *\n\t * Buffers commonly use the extension `.bin`, though this is not required.\n\t */\n\tpublic getURI(): string {\n\t\treturn this.get('uri');\n\t}\n\n\t/**\n\t * Sets the URI (or filename) of this buffer (e.g. 'myBuffer.bin'). URIs are strongly\n\t * encouraged to be relative paths, rather than absolute. Use of a protocol (like `file://`)\n\t * is possible for custom applications, but will limit the compatibility of the asset with most\n\t * tools.\n\t *\n\t * Buffers commonly use the extension `.bin`, though this is not required.\n\t */\n\tpublic setURI(uri: string): this {\n\t\treturn this.set('uri', uri);\n\t}\n}\n","import { Nullable, PropertyType } from '../constants';\nimport { GLTF } from '../types/gltf';\nimport { ExtensibleProperty, IExtensibleProperty } from './extensible-property';\n\ninterface ICamera extends IExtensibleProperty {\n\ttype: GLTF.CameraType;\n\tznear: number;\n\tzfar: number;\n\taspectRatio: number | null;\n\tyfov: number;\n\txmag: number;\n\tymag: number;\n}\n\n/**\n * # Camera\n *\n * *Cameras are perspectives through which the {@link Scene} may be viewed.*\n *\n * Projection can be perspective or orthographic. Cameras are contained in nodes and thus can be\n * transformed. The camera is defined such that the local +X axis is to the right, the lens looks\n * towards the local -Z axis, and the top of the camera is aligned with the local +Y axis. If no\n * transformation is specified, the location of the camera is at the origin.\n *\n * Usage:\n *\n * ```typescript\n * const camera = doc.createCamera('myCamera')\n * \t.setType(GLTF.CameraType.PERSPECTIVE)\n * \t.setZNear(0.1)\n * \t.setZFar(100)\n * \t.setYFov(Math.PI / 4)\n * \t.setAspectRatio(1.5);\n *\n * node.setCamera(camera);\n * ```\n *\n * References:\n * - [glTF → Cameras](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#cameras)\n *\n * @category Properties\n */\nexport class Camera extends ExtensibleProperty<ICamera> {\n\tpublic declare propertyType: PropertyType.CAMERA;\n\n\t/**********************************************************************************************\n\t * Constants.\n\t */\n\n\tpublic static Type: Record<string, GLTF.CameraType> = {\n\t\t/** A perspective camera representing a perspective projection matrix. */\n\t\tPERSPECTIVE: 'perspective',\n\t\t/** An orthographic camera representing an orthographic projection matrix. */\n\t\tORTHOGRAPHIC: 'orthographic',\n\t};\n\n\t/**********************************************************************************************\n\t * Instance.\n\t */\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.CAMERA;\n\t}\n\n\tprotected getDefaults(): Nullable<ICamera> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\t// Common.\n\t\t\ttype: Camera.Type.PERSPECTIVE,\n\t\t\tznear: 0.1,\n\t\t\tzfar: 100,\n\t\t\t// Perspective.\n\t\t\taspectRatio: null,\n\t\t\tyfov: (Math.PI * 2 * 50) / 360, // 50º\n\t\t\t// Orthographic.\n\t\t\txmag: 1,\n\t\t\tymag: 1,\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Common.\n\t */\n\n\t/** Specifies if the camera uses a perspective or orthographic projection. */\n\tpublic getType(): GLTF.CameraType {\n\t\treturn this.get('type');\n\t}\n\n\t/** Specifies if the camera uses a perspective or orthographic projection. */\n\tpublic setType(type: GLTF.CameraType): this {\n\t\treturn this.set('type', type);\n\t}\n\n\t/** Floating-point distance to the near clipping plane. */\n\tpublic getZNear(): number {\n\t\treturn this.get('znear');\n\t}\n\n\t/** Floating-point distance to the near clipping plane. */\n\tpublic setZNear(znear: number): this {\n\t\treturn this.set('znear', znear);\n\t}\n\n\t/**\n\t * Floating-point distance to the far clipping plane. When defined, zfar must be greater than\n\t * znear. If zfar is undefined, runtime must use infinite projection matrix.\n\t */\n\tpublic getZFar(): number {\n\t\treturn this.get('zfar');\n\t}\n\n\t/**\n\t * Floating-point distance to the far clipping plane. When defined, zfar must be greater than\n\t * znear. If zfar is undefined, runtime must use infinite projection matrix.\n\t */\n\tpublic setZFar(zfar: number): this {\n\t\treturn this.set('zfar', zfar);\n\t}\n\n\t/**********************************************************************************************\n\t * Perspective.\n\t */\n\n\t/**\n\t * Floating-point aspect ratio of the field of view. When undefined, the aspect ratio of the\n\t * canvas is used.\n\t */\n\tpublic getAspectRatio(): number | null {\n\t\treturn this.get('aspectRatio');\n\t}\n\n\t/**\n\t * Floating-point aspect ratio of the field of view. When undefined, the aspect ratio of the\n\t * canvas is used.\n\t */\n\tpublic setAspectRatio(aspectRatio: number | null): this {\n\t\treturn this.set('aspectRatio', aspectRatio);\n\t}\n\n\t/** Floating-point vertical field of view in radians. */\n\tpublic getYFov(): number {\n\t\treturn this.get('yfov');\n\t}\n\n\t/** Floating-point vertical field of view in radians. */\n\tpublic setYFov(yfov: number): this {\n\t\treturn this.set('yfov', yfov);\n\t}\n\n\t/**********************************************************************************************\n\t * Orthographic.\n\t */\n\n\t/**\n\t * Floating-point horizontal magnification of the view, and half the view's width\n\t * in world units.\n\t */\n\tpublic getXMag(): number {\n\t\treturn this.get('xmag');\n\t}\n\n\t/**\n\t * Floating-point horizontal magnification of the view, and half the view's width\n\t * in world units.\n\t */\n\tpublic setXMag(xmag: number): this {\n\t\treturn this.set('xmag', xmag);\n\t}\n\n\t/**\n\t * Floating-point vertical magnification of the view, and half the view's height\n\t * in world units.\n\t */\n\tpublic getYMag(): number {\n\t\treturn this.get('ymag');\n\t}\n\n\t/**\n\t * Floating-point vertical magnification of the view, and half the view's height\n\t * in world units.\n\t */\n\tpublic setYMag(ymag: number): this {\n\t\treturn this.set('ymag', ymag);\n\t}\n}\n","import { ExtensibleProperty } from './extensible-property';\nimport { Property, IProperty } from './property';\n\n/**\n * # ExtensionProperty\n *\n * *Base class for all {@link Property} types that can be attached by an {@link Extension}.*\n *\n * After an {@link Extension} is attached to a glTF {@link Document}, the Extension may be used to\n * construct ExtensionProperty instances, to be referenced throughout the document as prescribed by\n * the Extension. For example, the `KHR_materials_clearcoat` Extension defines a `Clearcoat`\n * ExtensionProperty, which is referenced by {@link Material} Properties in the Document, and may\n * contain references to {@link Texture} properties of its own.\n *\n * For more information on available extensions and their usage, see [Extensions](/extensions).\n *\n * Reference:\n * - [glTF → Extensions](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#specifying-extensions)\n */\nexport abstract class ExtensionProperty<T extends IProperty = IProperty> extends Property<T> {\n\tpublic static EXTENSION_NAME: string;\n\tpublic abstract readonly extensionName: string;\n\n\t/** List of supported {@link Property} types. */\n\tpublic abstract readonly parentTypes: string[];\n\n\t/** @hidden */\n\tpublic _validateParent(parent: ExtensibleProperty): void {\n\t\tif (!this.parentTypes.includes(parent.propertyType)) {\n\t\t\tthrow new Error(`Parent \"${parent.propertyType}\" invalid for child \"${this.propertyType}\".`);\n\t\t}\n\t}\n}\n","import { Nullable, PropertyType } from '../constants';\nimport { GLTF } from '../types/gltf';\nimport { ExtensibleProperty, IExtensibleProperty } from './extensible-property';\n\ninterface ITextureInfo extends IExtensibleProperty {\n\ttexCoord: number;\n\n\t// Sampler properties are also attached to TextureInfo, for simplicity.\n\tmagFilter: GLTF.TextureMagFilter | null;\n\tminFilter: GLTF.TextureMinFilter | null;\n\twrapS: GLTF.TextureWrapMode;\n\twrapT: GLTF.TextureWrapMode;\n}\n\n/**\n * # TextureInfo\n *\n * *Settings associated with a particular use of a {@link Texture}.*\n *\n * Different materials may reuse the same texture but with different texture coordinates,\n * minFilter/magFilter, or wrapS/wrapT settings. The TextureInfo class contains settings\n * derived from both the \"TextureInfo\" and \"Sampler\" properties in the glTF specification,\n * consolidated here for simplicity.\n *\n * TextureInfo properties cannot be directly created. For any material texture slot, such as\n * baseColorTexture, there will be a corresponding method to obtain the TextureInfo for that slot.\n * For example, see {@link Material.getBaseColorTextureInfo}.\n *\n * References:\n * - [glTF → Texture Info](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#reference-textureinfo)\n *\n * @category Properties\n */\nexport class TextureInfo extends ExtensibleProperty<ITextureInfo> {\n\tpublic declare propertyType: PropertyType.TEXTURE_INFO;\n\n\t/**********************************************************************************************\n\t * Constants.\n\t */\n\n\t/** UV wrapping mode. Values correspond to WebGL enums. */\n\tpublic static WrapMode: Record<string, GLTF.TextureWrapMode> = {\n\t\t/** */\n\t\tCLAMP_TO_EDGE: 33071,\n\t\t/** */\n\t\tMIRRORED_REPEAT: 33648,\n\t\t/** */\n\t\tREPEAT: 10497,\n\t};\n\n\t/** Magnification filter. Values correspond to WebGL enums. */\n\tpublic static MagFilter: Record<string, GLTF.TextureMagFilter> = {\n\t\t/** */\n\t\tNEAREST: 9728,\n\t\t/** */\n\t\tLINEAR: 9729,\n\t};\n\n\t/** Minification filter. Values correspond to WebGL enums. */\n\tpublic static MinFilter: Record<string, GLTF.TextureMinFilter> = {\n\t\t/** */\n\t\tNEAREST: 9728,\n\t\t/** */\n\t\tLINEAR: 9729,\n\t\t/** */\n\t\tNEAREST_MIPMAP_NEAREST: 9984,\n\t\t/** */\n\t\tLINEAR_MIPMAP_NEAREST: 9985,\n\t\t/** */\n\t\tNEAREST_MIPMAP_LINEAR: 9986,\n\t\t/** */\n\t\tLINEAR_MIPMAP_LINEAR: 9987,\n\t};\n\n\t/**********************************************************************************************\n\t * Instance.\n\t */\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.TEXTURE_INFO;\n\t}\n\n\tprotected getDefaults(): Nullable<ITextureInfo> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\ttexCoord: 0,\n\t\t\tmagFilter: null,\n\t\t\tminFilter: null,\n\t\t\twrapS: TextureInfo.WrapMode.REPEAT,\n\t\t\twrapT: TextureInfo.WrapMode.REPEAT,\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Texture coordinates.\n\t */\n\n\t/** Returns the texture coordinate (UV set) index for the texture. */\n\tpublic getTexCoord(): number {\n\t\treturn this.get('texCoord');\n\t}\n\n\t/** Sets the texture coordinate (UV set) index for the texture. */\n\tpublic setTexCoord(texCoord: number): this {\n\t\treturn this.set('texCoord', texCoord);\n\t}\n\n\t/**********************************************************************************************\n\t * Min/mag filter.\n\t */\n\n\t/** Returns the magnification filter applied to the texture. */\n\tpublic getMagFilter(): GLTF.TextureMagFilter | null {\n\t\treturn this.get('magFilter');\n\t}\n\n\t/** Sets the magnification filter applied to the texture. */\n\tpublic setMagFilter(magFilter: GLTF.TextureMagFilter | null): this {\n\t\treturn this.set('magFilter', magFilter);\n\t}\n\n\t/** Sets the minification filter applied to the texture. */\n\tpublic getMinFilter(): GLTF.TextureMinFilter | null {\n\t\treturn this.get('minFilter');\n\t}\n\n\t/** Returns the minification filter applied to the texture. */\n\tpublic setMinFilter(minFilter: GLTF.TextureMinFilter | null): this {\n\t\treturn this.set('minFilter', minFilter);\n\t}\n\n\t/**********************************************************************************************\n\t * UV wrapping.\n\t */\n\n\t/** Returns the S (U) wrapping mode for UVs used by the texture. */\n\tpublic getWrapS(): GLTF.TextureWrapMode {\n\t\treturn this.get('wrapS');\n\t}\n\n\t/** Sets the S (U) wrapping mode for UVs used by the texture. */\n\tpublic setWrapS(wrapS: GLTF.TextureWrapMode): this {\n\t\treturn this.set('wrapS', wrapS);\n\t}\n\n\t/** Returns the T (V) wrapping mode for UVs used by the texture. */\n\tpublic getWrapT(): GLTF.TextureWrapMode {\n\t\treturn this.get('wrapT');\n\t}\n\n\t/** Sets the T (V) wrapping mode for UVs used by the texture. */\n\tpublic setWrapT(wrapT: GLTF.TextureWrapMode): this {\n\t\treturn this.set('wrapT', wrapT);\n\t}\n}\n","import { Nullable, PropertyType, TextureChannel, vec3, vec4 } from '../constants';\nimport { GLTF } from '../types/gltf';\nimport { ColorUtils } from '../utils';\nimport { ExtensibleProperty, IExtensibleProperty } from './extensible-property';\nimport { Texture } from './texture';\nimport { TextureInfo } from './texture-info';\n\nconst { R, G, B, A } = TextureChannel;\n\ninterface IMaterial extends IExtensibleProperty {\n\talphaMode: GLTF.MaterialAlphaMode;\n\talphaCutoff: number;\n\tdoubleSided: boolean;\n\tbaseColorFactor: vec4;\n\tbaseColorTexture: Texture;\n\tbaseColorTextureInfo: TextureInfo;\n\temissiveFactor: vec3;\n\temissiveTexture: Texture;\n\temissiveTextureInfo: TextureInfo;\n\tnormalScale: number;\n\tnormalTexture: Texture;\n\tnormalTextureInfo: TextureInfo;\n\tocclusionStrength: number;\n\tocclusionTexture: Texture;\n\tocclusionTextureInfo: TextureInfo;\n\troughnessFactor: number;\n\tmetallicFactor: number;\n\tmetallicRoughnessTexture: Texture;\n\tmetallicRoughnessTextureInfo: TextureInfo;\n}\n\n/**\n * # Material\n *\n * *Materials describe a surface's appearance and response to light.*\n *\n * Each {@link Primitive} within a {@link Mesh} may be assigned a single Material. The number of\n * GPU draw calls typically increases with both the numbers of Primitives and of Materials in an\n * asset; Materials should be reused wherever possible. Techniques like texture atlasing and vertex\n * colors allow objects to have varied appearances while technically sharing a single Material.\n *\n * Material properties are modified by both scalars (like `baseColorFactor`) and textures (like\n * `baseColorTexture`). When both are available, factors are considered linear multipliers against\n * textures of the same name. In the case of base color, vertex colors (`COLOR_0` attributes) are\n * also multiplied.\n *\n * Textures containing color data (`baseColorTexture`, `emissiveTexture`) are sRGB. All other\n * textures are linear. Like other resources, textures should be reused when possible.\n *\n * Usage:\n *\n * ```typescript\n * const material = doc.createMaterial('myMaterial')\n * \t.setBaseColorFactor([1, 0.5, 0.5, 1]) // RGBA\n * \t.setOcclusionTexture(aoTexture)\n * \t.setOcclusionStrength(0.5);\n *\n * mesh.listPrimitives()\n * \t.forEach((prim) => prim.setMaterial(material));\n * ```\n *\n * @category Properties\n */\nexport class Material extends ExtensibleProperty<IMaterial> {\n\tpublic declare propertyType: PropertyType.MATERIAL;\n\n\t/**********************************************************************************************\n\t * Constants.\n\t */\n\n\tpublic static AlphaMode: Record<string, GLTF.MaterialAlphaMode> = {\n\t\t/**\n\t\t * The alpha value is ignored and the rendered output is fully opaque\n\t\t */\n\t\tOPAQUE: 'OPAQUE',\n\t\t/**\n\t\t * The rendered output is either fully opaque or fully transparent depending on the alpha\n\t\t * value and the specified alpha cutoff value\n\t\t */\n\t\tMASK: 'MASK',\n\t\t/**\n\t\t * The alpha value is used to composite the source and destination areas. The rendered\n\t\t * output is combined with the background using the normal painting operation (i.e. the\n\t\t * Porter and Duff over operator)\n\t\t */\n\t\tBLEND: 'BLEND',\n\t};\n\n\t/**********************************************************************************************\n\t * Instance.\n\t */\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.MATERIAL;\n\t}\n\n\tprotected getDefaults(): Nullable<IMaterial> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\talphaMode: Material.AlphaMode.OPAQUE,\n\t\t\talphaCutoff: 0.5,\n\t\t\tdoubleSided: false,\n\t\t\tbaseColorFactor: [1, 1, 1, 1] as vec4,\n\t\t\tbaseColorTexture: null,\n\t\t\tbaseColorTextureInfo: new TextureInfo(this.graph, 'baseColorTextureInfo'),\n\t\t\temissiveFactor: [0, 0, 0] as vec3,\n\t\t\temissiveTexture: null,\n\t\t\temissiveTextureInfo: new TextureInfo(this.graph, 'emissiveTextureInfo'),\n\t\t\tnormalScale: 1,\n\t\t\tnormalTexture: null,\n\t\t\tnormalTextureInfo: new TextureInfo(this.graph, 'normalTextureInfo'),\n\t\t\tocclusionStrength: 1,\n\t\t\tocclusionTexture: null,\n\t\t\tocclusionTextureInfo: new TextureInfo(this.graph, 'occlusionTextureInfo'),\n\t\t\troughnessFactor: 1,\n\t\t\tmetallicFactor: 1,\n\t\t\tmetallicRoughnessTexture: null,\n\t\t\tmetallicRoughnessTextureInfo: new TextureInfo(this.graph, 'metallicRoughnessTextureInfo'),\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Double-sided / culling.\n\t */\n\n\t/** Returns true when both sides of triangles should be rendered. May impact performance. */\n\tpublic getDoubleSided(): boolean {\n\t\treturn this.get('doubleSided');\n\t}\n\n\t/** Sets whether to render both sides of triangles. May impact performance. */\n\tpublic setDoubleSided(doubleSided: boolean): this {\n\t\treturn this.set('doubleSided', doubleSided);\n\t}\n\n\t/**********************************************************************************************\n\t * Alpha.\n\t */\n\n\t/** Returns material alpha, equivalent to baseColorFactor[3]. */\n\tpublic getAlpha(): number {\n\t\treturn this.get('baseColorFactor')[3];\n\t}\n\n\t/** Sets material alpha, equivalent to baseColorFactor[3]. */\n\tpublic setAlpha(alpha: number): this {\n\t\tconst baseColorFactor = this.get('baseColorFactor').slice() as vec4;\n\t\tbaseColorFactor[3] = alpha;\n\t\treturn this.set('baseColorFactor', baseColorFactor);\n\t}\n\n\t/**\n\t * Returns the mode of the material's alpha channels, which are provided by `baseColorFactor`\n\t * and `baseColorTexture`.\n\t *\n\t * - `OPAQUE`: Alpha value is ignored and the rendered output is fully opaque.\n\t * - `BLEND`: Alpha value is used to determine the transparency each pixel on a surface, and\n\t * \tthe fraction of surface vs. background color in the final result. Alpha blending creates\n\t *\tsignificant edge cases in realtime renderers, and some care when structuring the model is\n\t * \tnecessary for good results. In particular, transparent geometry should be kept in separate\n\t * \tmeshes or primitives from opaque geometry. The `depthWrite` or `zWrite` settings in engines\n\t * \tshould usually be disabled on transparent materials.\n\t * - `MASK`: Alpha value is compared against `alphaCutoff` threshold for each pixel on a\n\t * \tsurface, and the pixel is either fully visible or fully discarded based on that cutoff.\n\t * \tThis technique is useful for things like leafs/foliage, grass, fabric meshes, and other\n\t * \tsurfaces where no semitransparency is needed. With a good choice of `alphaCutoff`, surfaces\n\t * \tthat don't require semitransparency can avoid the performance penalties and visual issues\n\t * \tinvolved with `BLEND` transparency.\n\t *\n\t * Reference:\n\t * - [glTF → material.alphaMode](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materialalphamode)\n\t */\n\tpublic getAlphaMode(): GLTF.MaterialAlphaMode {\n\t\treturn this.get('alphaMode');\n\t}\n\n\t/** Sets the mode of the material's alpha channels. See {@link getAlphaMode} for details. */\n\tpublic setAlphaMode(alphaMode: GLTF.MaterialAlphaMode): this {\n\t\treturn this.set('alphaMode', alphaMode);\n\t}\n\n\t/** Returns the visibility threshold; applied only when `.alphaMode='MASK'`. */\n\tpublic getAlphaCutoff(): number {\n\t\treturn this.get('alphaCutoff');\n\t}\n\n\t/** Sets the visibility threshold; applied only when `.alphaMode='MASK'`. */\n\tpublic setAlphaCutoff(alphaCutoff: number): this {\n\t\treturn this.set('alphaCutoff', alphaCutoff);\n\t}\n\n\t/**********************************************************************************************\n\t * Base color.\n\t */\n\n\t/** Base color / albedo factor; Linear-sRGB components. See {@link getBaseColorTexture}. */\n\tpublic getBaseColorFactor(): vec4 {\n\t\treturn this.get('baseColorFactor');\n\t}\n\n\t/** Base color / albedo factor; Linear-sRGB components. See {@link getBaseColorTexture}. */\n\tpublic setBaseColorFactor(baseColorFactor: vec4): this {\n\t\treturn this.set('baseColorFactor', baseColorFactor);\n\t}\n\n\t/**\n\t * Base color / albedo; sRGB hexadecimal color. See {@link getBaseColorTexture}.\n\t */\n\tpublic getBaseColorHex(): number {\n\t\treturn ColorUtils.factorToHex(this.get('baseColorFactor'));\n\t}\n\n\t/**\n\t * Base color / albedo; sRGB hexadecimal color. See {@link getBaseColorTexture}.\n\t */\n\tpublic setBaseColorHex(hex: number): this {\n\t\tconst factor = this.get('baseColorFactor').slice() as vec4;\n\t\treturn this.set('baseColorFactor', ColorUtils.hexToFactor(hex, factor));\n\t}\n\n\t/**\n\t * Base color / albedo. The visible color of a non-metallic surface under constant ambient\n\t * light would be a linear combination (multiplication) of its vertex colors, base color\n\t * factor, and base color texture. Lighting, and reflections in metallic or smooth surfaces,\n\t * also effect the final color. The alpha (`.a`) channel of base color factors and textures\n\t * will have varying effects, based on the setting of {@link getAlphaMode}.\n\t *\n\t * Reference:\n\t * - [glTF → material.pbrMetallicRoughness.baseColorFactor](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#pbrmetallicroughnessbasecolorfactor)\n\t */\n\tpublic getBaseColorTexture(): Texture | null {\n\t\treturn this.getRef('baseColorTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its base color texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getBaseColorTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('baseColorTexture') ? this.getRef('baseColorTextureInfo') : null;\n\t}\n\n\t/** Sets base color / albedo texture. See {@link getBaseColorTexture}. */\n\tpublic setBaseColorTexture(texture: Texture | null): this {\n\t\treturn this.setRef('baseColorTexture', texture, { channels: R | G | B | A });\n\t}\n\n\t/**********************************************************************************************\n\t * Emissive.\n\t */\n\n\t/** Emissive color; Linear-sRGB components. See {@link getEmissiveTexture}. */\n\tpublic getEmissiveFactor(): vec3 {\n\t\treturn this.get('emissiveFactor');\n\t}\n\n\t/** Emissive color; Linear-sRGB components. See {@link getEmissiveTexture}. */\n\tpublic setEmissiveFactor(emissiveFactor: vec3): this {\n\t\treturn this.set('emissiveFactor', emissiveFactor);\n\t}\n\n\t/** Emissive; sRGB hexadecimal color. See {@link getBaseColorTexture}. */\n\tpublic getEmissiveHex(): number {\n\t\treturn ColorUtils.factorToHex(this.get('emissiveFactor'));\n\t}\n\n\t/** Emissive; sRGB hexadecimal color. See {@link getEmissiveTexture}. */\n\tpublic setEmissiveHex(hex: number): this {\n\t\tconst factor = this.get('emissiveFactor').slice() as vec3;\n\t\treturn this.set('emissiveFactor', ColorUtils.hexToFactor(hex, factor));\n\t}\n\n\t/**\n\t * Emissive texture. Emissive color is added to any base color of the material, after any\n\t * lighting/shadowing are applied. An emissive color does not inherently \"glow\", or affect\n\t * objects around it at all. To create that effect, most viewers must also enable a\n\t * post-processing effect called \"bloom\".\n\t *\n\t * Reference:\n\t * - [glTF → material.emissiveTexture](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materialemissivetexture)\n\t */\n\tpublic getEmissiveTexture(): Texture | null {\n\t\treturn this.getRef('emissiveTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its emissive texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getEmissiveTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('emissiveTexture') ? this.getRef('emissiveTextureInfo') : null;\n\t}\n\n\t/** Sets emissive texture. See {@link getEmissiveTexture}. */\n\tpublic setEmissiveTexture(texture: Texture | null): this {\n\t\treturn this.setRef('emissiveTexture', texture, { channels: R | G | B });\n\t}\n\n\t/**********************************************************************************************\n\t * Normal.\n\t */\n\n\t/** Normal (surface detail) factor; linear multiplier. Affects `.normalTexture`. */\n\tpublic getNormalScale(): number {\n\t\treturn this.get('normalScale');\n\t}\n\n\t/** Normal (surface detail) factor; linear multiplier. Affects `.normalTexture`. */\n\tpublic setNormalScale(scale: number): this {\n\t\treturn this.set('normalScale', scale);\n\t}\n\n\t/**\n\t * Normal (surface detail) texture.\n\t *\n\t * A tangent space normal map. The texture contains RGB components. Each texel represents the\n\t * XYZ components of a normal vector in tangent space. Red [0 to 255] maps to X [-1 to 1].\n\t * Green [0 to 255] maps to Y [-1 to 1]. Blue [128 to 255] maps to Z [1/255 to 1]. The normal\n\t * vectors use OpenGL conventions where +X is right and +Y is up. +Z points toward the viewer.\n\t *\n\t * Reference:\n\t * - [glTF → material.normalTexture](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materialnormaltexture)\n\t */\n\tpublic getNormalTexture(): Texture | null {\n\t\treturn this.getRef('normalTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its normal texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getNormalTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('normalTexture') ? this.getRef('normalTextureInfo') : null;\n\t}\n\n\t/** Sets normal (surface detail) texture. See {@link getNormalTexture}. */\n\tpublic setNormalTexture(texture: Texture | null): this {\n\t\treturn this.setRef('normalTexture', texture, { channels: R | G | B });\n\t}\n\n\t/**********************************************************************************************\n\t * Occlusion.\n\t */\n\n\t/** (Ambient) Occlusion factor; linear multiplier. Affects `.occlusionTexture`. */\n\tpublic getOcclusionStrength(): number {\n\t\treturn this.get('occlusionStrength');\n\t}\n\n\t/** Sets (ambient) occlusion factor; linear multiplier. Affects `.occlusionTexture`. */\n\tpublic setOcclusionStrength(strength: number): this {\n\t\treturn this.set('occlusionStrength', strength);\n\t}\n\n\t/**\n\t * (Ambient) Occlusion texture, generally used for subtle 'baked' shadowing effects that are\n\t * independent of an object's position, such as shading in inset areas and corners. Direct\n\t * lighting is not affected by occlusion, so at least one indirect light source must be present\n\t * in the scene for occlusion effects to be visible.\n\t *\n\t * The occlusion values are sampled from the R channel. Higher values indicate areas that\n\t * should receive full indirect lighting and lower values indicate no indirect lighting.\n\t *\n\t * Reference:\n\t * - [glTF → material.occlusionTexture](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materialocclusiontexture)\n\t */\n\tpublic getOcclusionTexture(): Texture | null {\n\t\treturn this.getRef('occlusionTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its occlusion texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getOcclusionTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('occlusionTexture') ? this.getRef('occlusionTextureInfo') : null;\n\t}\n\n\t/** Sets (ambient) occlusion texture. See {@link getOcclusionTexture}. */\n\tpublic setOcclusionTexture(texture: Texture | null): this {\n\t\treturn this.setRef('occlusionTexture', texture, { channels: R });\n\t}\n\n\t/**********************************************************************************************\n\t * Metallic / roughness.\n\t */\n\n\t/**\n\t * Roughness factor; linear multiplier. Affects roughness channel of\n\t * `metallicRoughnessTexture`. See {@link getMetallicRoughnessTexture}.\n\t */\n\tpublic getRoughnessFactor(): number {\n\t\treturn this.get('roughnessFactor');\n\t}\n\n\t/**\n\t * Sets roughness factor; linear multiplier. Affects roughness channel of\n\t * `metallicRoughnessTexture`. See {@link getMetallicRoughnessTexture}.\n\t */\n\tpublic setRoughnessFactor(factor: number): this {\n\t\treturn this.set('roughnessFactor', factor);\n\t}\n\n\t/**\n\t * Metallic factor; linear multiplier. Affects roughness channel of\n\t * `metallicRoughnessTexture`. See {@link getMetallicRoughnessTexture}.\n\t */\n\tpublic getMetallicFactor(): number {\n\t\treturn this.get('metallicFactor');\n\t}\n\n\t/**\n\t * Sets metallic factor; linear multiplier. Affects roughness channel of\n\t * `metallicRoughnessTexture`. See {@link getMetallicRoughnessTexture}.\n\t */\n\tpublic setMetallicFactor(factor: number): this {\n\t\treturn this.set('metallicFactor', factor);\n\t}\n\n\t/**\n\t * Metallic roughness texture. The metalness values are sampled from the B channel. The\n\t * roughness values are sampled from the G channel. When a material is fully metallic,\n\t * or nearly so, it may require image-based lighting (i.e. an environment map) or global\n\t * illumination to appear well-lit.\n\t *\n\t * Reference:\n\t * - [glTF → material.pbrMetallicRoughness.metallicRoughnessTexture](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#pbrmetallicroughnessmetallicroughnesstexture)\n\t */\n\tpublic getMetallicRoughnessTexture(): Texture | null {\n\t\treturn this.getRef('metallicRoughnessTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its metallic/roughness texture. If no texture is\n\t * attached, {@link TextureInfo} is `null`.\n\t */\n\tpublic getMetallicRoughnessTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('metallicRoughnessTexture') ? this.getRef('metallicRoughnessTextureInfo') : null;\n\t}\n\n\t/** Sets metallic/roughness texture. See {@link getMetallicRoughnessTexture}. */\n\tpublic setMetallicRoughnessTexture(texture: Texture | null): this {\n\t\treturn this.setRef('metallicRoughnessTexture', texture, { channels: G | B });\n\t}\n}\n","import { Nullable, PropertyType } from '../constants';\nimport { ExtensibleProperty, IExtensibleProperty } from './extensible-property';\nimport { Primitive } from './primitive';\n\ninterface IMesh extends IExtensibleProperty {\n\tweights: number[];\n\tprimitives: Primitive[];\n}\n\n/**\n * # Mesh\n *\n * *Meshes define reusable geometry (triangles, lines, or points) and are instantiated by\n * {@link Node}s.*\n *\n * Each draw call required to render a mesh is represented as a {@link Primitive}. Meshes typically\n * have only a single {@link Primitive}, but may have more for various reasons. A mesh manages only\n * a list of primitives — materials, morph targets, and other properties are managed on a per-\n * primitive basis.\n *\n * When the same geometry and material should be rendered at multiple places in the scene, reuse\n * the same Mesh instance and attach it to multiple nodes for better efficiency. Where the geometry\n * is shared but the material is not, reusing {@link Accessor}s under different meshes and\n * primitives can similarly improve transmission efficiency, although some rendering efficiency is\n * lost as the number of materials in a scene increases.\n *\n * Usage:\n *\n * ```ts\n * const primitive = doc.createPrimitive()\n * \t.setAttribute('POSITION', positionAccessor)\n * \t.setAttribute('TEXCOORD_0', uvAccessor);\n * const mesh = doc.createMesh('myMesh')\n * \t.addPrimitive(primitive);\n * node.setMesh(mesh);\n * ```\n *\n * References:\n * - [glTF → Geometry](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry)\n *\n * @category Properties\n */\nexport class Mesh extends ExtensibleProperty<IMesh> {\n\tpublic declare propertyType: PropertyType.MESH;\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.MESH;\n\t}\n\n\tprotected getDefaults(): Nullable<IMesh> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, { weights: [], primitives: [] });\n\t}\n\n\t/** Adds a {@link Primitive} to the mesh's draw call list. */\n\tpublic addPrimitive(primitive: Primitive): this {\n\t\treturn this.addRef('primitives', primitive);\n\t}\n\n\t/** Removes a {@link Primitive} from the mesh's draw call list. */\n\tpublic removePrimitive(primitive: Primitive): this {\n\t\treturn this.removeRef('primitives', primitive);\n\t}\n\n\t/** Lists {@link Primitive} draw calls of the mesh. */\n\tpublic listPrimitives(): Primitive[] {\n\t\treturn this.listRefs('primitives');\n\t}\n\n\t/**\n\t * Initial weights of each {@link PrimitiveTarget} on this mesh. Each {@link Primitive} must\n\t * have the same number of targets. Most engines only support 4-8 active morph targets at a\n\t * time.\n\t */\n\tpublic getWeights(): number[] {\n\t\treturn this.get('weights');\n\t}\n\n\t/**\n\t * Initial weights of each {@link PrimitiveTarget} on this mesh. Each {@link Primitive} must\n\t * have the same number of targets. Most engines only support 4-8 active morph targets at a\n\t * time.\n\t */\n\tpublic setWeights(weights: number[]): this {\n\t\treturn this.set('weights', weights);\n\t}\n}\n","import { multiply } from 'gl-matrix/mat4';\nimport { PropertyType, mat4, vec3, vec4, Nullable } from '../constants';\nimport { $attributes } from 'property-graph';\nimport { MathUtils } from '../utils';\nimport { Camera } from './camera';\nimport { ExtensibleProperty, IExtensibleProperty } from './extensible-property';\nimport { Mesh } from './mesh';\nimport { COPY_IDENTITY } from './property';\nimport { Skin } from './skin';\n\ninterface INode extends IExtensibleProperty {\n\ttranslation: vec3;\n\trotation: vec4;\n\tscale: vec3;\n\tweights: number[];\n\tcamera: Camera;\n\tmesh: Mesh;\n\tskin: Skin;\n\tchildren: Node[];\n}\n\n/**\n * # Node\n *\n * *Nodes are the objects that comprise a {@link Scene}.*\n *\n * Each node may have one or more children, and a transform (position, rotation, and scale) that\n * applies to all of its descendants. A node may also reference (or \"instantiate\") other resources\n * at its location, including {@link Mesh}, Camera, Light, and Skin properties. A node cannot be\n * part of more than one {@link Scene}.\n *\n * A node's local transform is represented with array-like objects, intended to be compatible with\n * [gl-matrix](https://github.com/toji/gl-matrix), or with the `toArray`/`fromArray` methods of\n * libraries like three.js and babylon.js.\n *\n * Usage:\n *\n * ```ts\n * const node = doc.createNode('myNode')\n * \t.setMesh(mesh)\n * \t.setTranslation([0, 0, 0])\n * \t.addChild(otherNode);\n * ```\n *\n * References:\n * - [glTF → Nodes and Hierarchy](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#nodes-and-hierarchy)\n *\n * @category Properties\n */\nexport class Node extends ExtensibleProperty<INode> {\n\tpublic declare propertyType: PropertyType.NODE;\n\n\t/** @internal Internal reference to node's parent, omitted from {@link Graph}. */\n\tpublic _parent: SceneNode | null = null;\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.NODE;\n\t}\n\n\tprotected getDefaults(): Nullable<INode> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\ttranslation: [0, 0, 0] as vec3,\n\t\t\trotation: [0, 0, 0, 1] as vec4,\n\t\t\tscale: [1, 1, 1] as vec3,\n\t\t\tweights: [],\n\t\t\tcamera: null,\n\t\t\tmesh: null,\n\t\t\tskin: null,\n\t\t\tchildren: [],\n\t\t});\n\t}\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\t// Node cannot be copied, only cloned. Copying is shallow, but nodes cannot have more than\n\t\t// one parent. Rather than leaving one of the two nodes without children, throw an error here.\n\t\tif (resolve === COPY_IDENTITY) throw new Error('Node cannot be copied.');\n\t\treturn super.copy(other, resolve);\n\t}\n\n\t/**********************************************************************************************\n\t * Local transform.\n\t */\n\n\t/** Returns the translation (position) of this node in local space. */\n\tpublic getTranslation(): vec3 {\n\t\treturn this.get('translation');\n\t}\n\n\t/** Returns the rotation (quaternion) of this node in local space. */\n\tpublic getRotation(): vec4 {\n\t\treturn this.get('rotation');\n\t}\n\n\t/** Returns the scale of this node in local space. */\n\tpublic getScale(): vec3 {\n\t\treturn this.get('scale');\n\t}\n\n\t/** Sets the translation (position) of this node in local space. */\n\tpublic setTranslation(translation: vec3): this {\n\t\treturn this.set('translation', translation);\n\t}\n\n\t/** Sets the rotation (quaternion) of this node in local space. */\n\tpublic setRotation(rotation: vec4): this {\n\t\treturn this.set('rotation', rotation);\n\t}\n\n\t/** Sets the scale of this node in local space. */\n\tpublic setScale(scale: vec3): this {\n\t\treturn this.set('scale', scale);\n\t}\n\n\t/** Returns the local matrix of this node. */\n\tpublic getMatrix(): mat4 {\n\t\treturn MathUtils.compose(\n\t\t\tthis.get('translation'),\n\t\t\tthis.get('rotation'),\n\t\t\tthis.get('scale'),\n\t\t\t[] as unknown as mat4\n\t\t);\n\t}\n\n\t/** Sets the local matrix of this node. Matrix will be decomposed to TRS properties. */\n\tpublic setMatrix(matrix: mat4): this {\n\t\tconst translation = this.get('translation').slice() as vec3;\n\t\tconst rotation = this.get('rotation').slice() as vec4;\n\t\tconst scale = this.get('scale').slice() as vec3;\n\t\tMathUtils.decompose(matrix, translation, rotation, scale);\n\t\treturn this.set('translation', translation).set('rotation', rotation).set('scale', scale);\n\t}\n\n\t/**********************************************************************************************\n\t * World transform.\n\t */\n\n\t/** Returns the translation (position) of this node in world space. */\n\tpublic getWorldTranslation(): vec3 {\n\t\tconst t = [0, 0, 0] as vec3;\n\t\tMathUtils.decompose(this.getWorldMatrix(), t, [0, 0, 0, 1], [1, 1, 1]);\n\t\treturn t;\n\t}\n\n\t/** Returns the rotation (quaternion) of this node in world space. */\n\tpublic getWorldRotation(): vec4 {\n\t\tconst r = [0, 0, 0, 1] as vec4;\n\t\tMathUtils.decompose(this.getWorldMatrix(), [0, 0, 0], r, [1, 1, 1]);\n\t\treturn r;\n\t}\n\n\t/** Returns the scale of this node in world space. */\n\tpublic getWorldScale(): vec3 {\n\t\tconst s = [1, 1, 1] as vec3;\n\t\tMathUtils.decompose(this.getWorldMatrix(), [0, 0, 0], [0, 0, 0, 1], s);\n\t\treturn s;\n\t}\n\n\t/** Returns the world matrix of this node. */\n\tpublic getWorldMatrix(): mat4 {\n\t\t// Build ancestor chain.\n\t\tconst ancestors: Node[] = [];\n\t\t// eslint-disable-next-line @typescript-eslint/no-this-alias\n\t\tfor (let node: SceneNode | null = this; node instanceof Node; node = node._parent) {\n\t\t\tancestors.push(node);\n\t\t}\n\n\t\t// Compute world matrix.\n\t\tlet ancestor: Node | undefined;\n\t\tconst worldMatrix = ancestors.pop()!.getMatrix();\n\t\twhile ((ancestor = ancestors.pop())) {\n\t\t\tmultiply(worldMatrix, worldMatrix, ancestor.getMatrix());\n\t\t}\n\n\t\treturn worldMatrix;\n\t}\n\n\t/**********************************************************************************************\n\t * Scene hierarchy.\n\t */\n\n\t/** Adds another node as a child of this one. Nodes cannot have multiple parents. */\n\tpublic addChild(child: Node): this {\n\t\t// Remove existing parent.\n\t\tif (child._parent) child._parent.removeChild(child);\n\n\t\t// Edge in graph.\n\t\tthis.addRef('children', child);\n\n\t\t// Set new parent.\n\t\t// TODO(cleanup): Avoid using $attributes here?\n\t\tchild._parent = this;\n\t\tconst childrenRefs = this[$attributes]['children'];\n\t\tconst ref = childrenRefs[childrenRefs.length - 1];\n\t\tref.addEventListener('dispose', () => (child._parent = null));\n\t\treturn this;\n\t}\n\n\t/** Removes a node from this node's child node list. */\n\tpublic removeChild(child: Node): this {\n\t\treturn this.removeRef('children', child);\n\t}\n\n\t/** Lists all child nodes of this node. */\n\tpublic listChildren(): Node[] {\n\t\treturn this.listRefs('children');\n\t}\n\n\t/**\n\t * Returns the unique parent ({@link Scene}, {@link Node}, or null) of this node in the scene\n\t * hierarchy. Unrelated to {@link Property.listParents}, which lists all resource references.\n\t */\n\tpublic getParent(): SceneNode | null {\n\t\treturn this._parent;\n\t}\n\n\t/**********************************************************************************************\n\t * Attachments.\n\t */\n\n\t/** Returns the {@link Mesh}, if any, instantiated at this node. */\n\tpublic getMesh(): Mesh | null {\n\t\treturn this.getRef('mesh');\n\t}\n\n\t/**\n\t * Sets a {@link Mesh} to be instantiated at this node. A single mesh may be instatiated by\n\t * multiple nodes; reuse of this sort is strongly encouraged.\n\t */\n\tpublic setMesh(mesh: Mesh | null): this {\n\t\treturn this.setRef('mesh', mesh);\n\t}\n\n\t/** Returns the {@link Camera}, if any, instantiated at this node. */\n\tpublic getCamera(): Camera | null {\n\t\treturn this.getRef('camera');\n\t}\n\n\t/** Sets a {@link Camera} to be instantiated at this node. */\n\tpublic setCamera(camera: Camera | null): this {\n\t\treturn this.setRef('camera', camera);\n\t}\n\n\t/** Returns the {@link Skin}, if any, instantiated at this node. */\n\tpublic getSkin(): Skin | null {\n\t\treturn this.getRef('skin');\n\t}\n\n\t/** Sets a {@link Skin} to be instantiated at this node. */\n\tpublic setSkin(skin: Skin | null): this {\n\t\treturn this.setRef('skin', skin);\n\t}\n\n\t/**\n\t * Initial weights of each {@link PrimitiveTarget} for the mesh instance at this node.\n\t * Most engines only support 4-8 active morph targets at a time.\n\t */\n\tpublic getWeights(): number[] {\n\t\treturn this.get('weights');\n\t}\n\n\t/**\n\t * Initial weights of each {@link PrimitiveTarget} for the mesh instance at this node.\n\t * Most engines only support 4-8 active morph targets at a time.\n\t */\n\tpublic setWeights(weights: number[]): this {\n\t\treturn this.set('weights', weights);\n\t}\n\n\t/**********************************************************************************************\n\t * Helpers.\n\t */\n\n\t/** Visits this {@link Node} and its descendants, top-down. */\n\tpublic traverse(fn: (node: Node) => void): this {\n\t\tfn(this);\n\t\tfor (const child of this.listChildren()) child.traverse(fn);\n\t\treturn this;\n\t}\n}\n\ninterface SceneNode {\n\tpropertyType: PropertyType;\n\t_parent?: SceneNode | null;\n\taddChild(node: Node): this;\n\tremoveChild(node: Node): this;\n}\n","import { BufferViewUsage, Nullable, PropertyType } from '../constants';\nimport { GLTF } from '../types/gltf';\nimport { Accessor } from './accessor';\nimport { ExtensibleProperty, IExtensibleProperty } from './extensible-property';\nimport { Material } from './material';\nimport { PrimitiveTarget } from './primitive-target';\n\ninterface IPrimitive extends IExtensibleProperty {\n\tmode: GLTF.MeshPrimitiveMode;\n\tmaterial: Material;\n\tindices: Accessor;\n\tattributes: { [key: string]: Accessor };\n\ttargets: PrimitiveTarget[];\n}\n\n/**\n * # Primitive\n *\n * *Primitives are individual GPU draw calls comprising a {@link Mesh}.*\n *\n * Meshes typically have only a single Primitive, although various cases may require more. Each\n * primitive may be assigned vertex attributes, morph target attributes, and a material. Any of\n * these properties should be reused among multiple primitives where feasible.\n *\n * Primitives cannot be moved independently of other primitives within the same mesh, except\n * through the use of morph targets and skinning. If independent movement or other runtime\n * behavior is necessary (like raycasting or collisions) prefer to assign each primitive to a\n * different mesh. The number of GPU draw calls is typically not affected by grouping or\n * ungrouping primitives to a mesh.\n *\n * Each primitive may optionally be deformed by one or more morph targets, stored in a\n * {@link PrimitiveTarget}.\n *\n * Usage:\n *\n * ```ts\n * const primitive = doc.createPrimitive()\n * \t.setAttribute('POSITION', positionAccessor)\n * \t.setAttribute('TEXCOORD_0', uvAccessor)\n * \t.setMaterial(material);\n * mesh.addPrimitive(primitive);\n * node.setMesh(mesh);\n * ```\n *\n * References:\n * - [glTF → Geometry](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry)\n *\n * @category Properties\n */\nexport class Primitive extends ExtensibleProperty<IPrimitive> {\n\tpublic declare propertyType: PropertyType.PRIMITIVE;\n\n\t/**********************************************************************************************\n\t * Constants.\n\t */\n\n\t/** Type of primitives to render. All valid values correspond to WebGL enums. */\n\tpublic static Mode: Record<string, GLTF.MeshPrimitiveMode> = {\n\t\t/** Draw single points. */\n\t\tPOINTS: 0,\n\t\t/** Draw lines. Each vertex connects to the one after it. */\n\t\tLINES: 1,\n\t\t/**\n\t\t * Draw lines. Each set of two vertices is treated as a separate line segment.\n\t\t * @deprecated See {@link https://github.com/KhronosGroup/glTF/issues/1883 KhronosGroup/glTF#1883}.\n\t\t */\n\t\tLINE_LOOP: 2,\n\t\t/** Draw a connected group of line segments from the first vertex to the last,  */\n\t\tLINE_STRIP: 3,\n\t\t/** Draw triangles. Each set of three vertices creates a separate triangle. */\n\t\tTRIANGLES: 4,\n\t\t/** Draw a connected strip of triangles. */\n\t\tTRIANGLE_STRIP: 5,\n\t\t/**\n\t\t * Draw a connected group of triangles. Each vertex connects to the previous and the first\n\t\t * vertex in the fan.\n\t\t * @deprecated See {@link https://github.com/KhronosGroup/glTF/issues/1883 KhronosGroup/glTF#1883}.\n\t\t */\n\t\tTRIANGLE_FAN: 6,\n\t};\n\n\t/**********************************************************************************************\n\t * Instance.\n\t */\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.PRIMITIVE;\n\t}\n\n\tprotected getDefaults(): Nullable<IPrimitive> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\tmode: Primitive.Mode.TRIANGLES,\n\t\t\tmaterial: null,\n\t\t\tindices: null,\n\t\t\tattributes: {},\n\t\t\ttargets: [],\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Primitive data.\n\t */\n\n\t/** Returns an {@link Accessor} with indices of vertices to be drawn. */\n\tpublic getIndices(): Accessor | null {\n\t\treturn this.getRef('indices');\n\t}\n\n\t/**\n\t * Sets an {@link Accessor} with indices of vertices to be drawn. In `TRIANGLES` draw mode,\n\t * each set of three indices define a triangle. The front face has a counter-clockwise (CCW)\n\t * winding order.\n\t */\n\tpublic setIndices(indices: Accessor | null): this {\n\t\treturn this.setRef('indices', indices, { usage: BufferViewUsage.ELEMENT_ARRAY_BUFFER });\n\t}\n\n\t/** Returns a vertex attribute as an {@link Accessor}. */\n\tpublic getAttribute(semantic: string): Accessor | null {\n\t\treturn this.getRefMap('attributes', semantic);\n\t}\n\n\t/**\n\t * Sets a vertex attribute to an {@link Accessor}. All attributes must have the same vertex\n\t * count.\n\t */\n\tpublic setAttribute(semantic: string, accessor: Accessor | null): this {\n\t\treturn this.setRefMap('attributes', semantic, accessor, { usage: BufferViewUsage.ARRAY_BUFFER });\n\t}\n\n\t/**\n\t * Lists all vertex attribute {@link Accessor}s associated with the primitive, excluding any\n\t * attributes used for morph targets. For example, `[positionAccessor, normalAccessor,\n\t * uvAccessor]`. Order will be consistent with the order returned by {@link .listSemantics}().\n\t */\n\tpublic listAttributes(): Accessor[] {\n\t\treturn this.listRefMapValues('attributes');\n\t}\n\n\t/**\n\t * Lists all vertex attribute semantics associated with the primitive, excluding any semantics\n\t * used for morph targets. For example, `['POSITION', 'NORMAL', 'TEXCOORD_0']`. Order will be\n\t * consistent with the order returned by {@link .listAttributes}().\n\t */\n\tpublic listSemantics(): string[] {\n\t\treturn this.listRefMapKeys('attributes');\n\t}\n\n\t/** Returns the material used to render the primitive. */\n\tpublic getMaterial(): Material | null {\n\t\treturn this.getRef('material');\n\t}\n\n\t/** Sets the material used to render the primitive. */\n\tpublic setMaterial(material: Material | null): this {\n\t\treturn this.setRef('material', material);\n\t}\n\n\t/**********************************************************************************************\n\t * Mode.\n\t */\n\n\t/**\n\t * Returns the GPU draw mode (`TRIANGLES`, `LINES`, `POINTS`...) as a WebGL enum value.\n\t *\n\t * Reference:\n\t * - [glTF → `primitive.mode`](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#primitivemode)\n\t */\n\tpublic getMode(): GLTF.MeshPrimitiveMode {\n\t\treturn this.get('mode');\n\t}\n\n\t/**\n\t * Sets the GPU draw mode (`TRIANGLES`, `LINES`, `POINTS`...) as a WebGL enum value.\n\t *\n\t * Reference:\n\t * - [glTF → `primitive.mode`](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#primitivemode)\n\t */\n\tpublic setMode(mode: GLTF.MeshPrimitiveMode): this {\n\t\treturn this.set('mode', mode);\n\t}\n\n\t/**********************************************************************************************\n\t * Morph targets.\n\t */\n\n\t/** Lists all morph targets associated with the primitive. */\n\tpublic listTargets(): PrimitiveTarget[] {\n\t\treturn this.listRefs('targets');\n\t}\n\n\t/**\n\t * Adds a morph target to the primitive. All primitives in the same mesh must have the same\n\t * number of targets.\n\t */\n\tpublic addTarget(target: PrimitiveTarget): this {\n\t\treturn this.addRef('targets', target);\n\t}\n\n\t/**\n\t * Removes a morph target from the primitive. All primitives in the same mesh must have the same\n\t * number of targets.\n\t */\n\tpublic removeTarget(target: PrimitiveTarget): this {\n\t\treturn this.removeRef('targets', target);\n\t}\n}\n","import { BufferViewUsage, Nullable, PropertyType } from '../constants';\nimport { Accessor } from './accessor';\nimport { IExtensibleProperty } from './extensible-property';\nimport { Property } from './property';\n\ninterface IPrimitiveTarget extends IExtensibleProperty {\n\tattributes: { [key: string]: Accessor };\n}\n\n/**\n * # PrimitiveTarget\n *\n * *Morph target or shape key used to deform one {@link Primitive} in a {@link Mesh}.*\n *\n * A PrimitiveTarget contains a `POSITION` attribute (and optionally `NORMAL` and `TANGENT`) that\n * can additively deform the base attributes on a {@link Mesh} {@link Primitive}. Vertex values\n * of `0, 0, 0` in the target will have no effect, whereas a value of `0, 1, 0` would offset that\n * vertex in the base geometry by y+=1. Morph targets can be fully or partially applied: their\n * default state is controlled by {@link Mesh.getWeights}, which can also be overridden for a\n * particular instantiation of a {@link Mesh}, using {@link Node.getWeights}.\n *\n * Reference:\n * - [glTF → Morph Targets](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets)\n */\nexport class PrimitiveTarget extends Property<IPrimitiveTarget> {\n\tpublic declare propertyType: PropertyType.PRIMITIVE_TARGET;\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.PRIMITIVE_TARGET;\n\t}\n\n\tprotected getDefaults(): Nullable<IPrimitiveTarget> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, { attributes: {} });\n\t}\n\n\t/** Returns a morph target vertex attribute as an {@link Accessor}. */\n\tpublic getAttribute(semantic: string): Accessor | null {\n\t\treturn this.getRefMap('attributes', semantic);\n\t}\n\n\t/**\n\t * Sets a morph target vertex attribute to an {@link Accessor}.\n\t */\n\tpublic setAttribute(semantic: string, accessor: Accessor | null): this {\n\t\treturn this.setRefMap('attributes', semantic, accessor, { usage: BufferViewUsage.ARRAY_BUFFER });\n\t}\n\n\t/**\n\t * Lists all morph target vertex attribute {@link Accessor}s associated. Order will be\n\t * consistent with the order returned by {@link .listSemantics}().\n\t */\n\tpublic listAttributes(): Accessor[] {\n\t\treturn this.listRefMapValues('attributes');\n\t}\n\n\t/**\n\t * Lists all morph target vertex attribute semantics associated. Order will be\n\t * consistent with the order returned by {@link .listAttributes}().\n\t */\n\tpublic listSemantics(): string[] {\n\t\treturn this.listRefMapKeys('attributes');\n\t}\n}\n","import { Nullable, PropertyType } from '../constants';\nimport { $attributes } from 'property-graph';\nimport { ExtensibleProperty, IExtensibleProperty } from './extensible-property';\nimport { Node } from './node';\nimport { COPY_IDENTITY } from './property';\n\ninterface IScene extends IExtensibleProperty {\n\tchildren: Node[];\n}\n\n/**\n * # Scene\n *\n * *Scenes represent a set of visual objects to render.*\n *\n * Typically a glTF file contains only a single scene, although more are allowed and useful in some\n * cases. No particular meaning is associated with additional scenes, except as defined by the\n * application. Scenes reference {@link Node}s, and a single node cannot be a member of more than\n * one scene.\n *\n * References:\n * - [glTF → Scenes](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#scenes)\n * - [glTF → Coordinate System and Units](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#coordinate-system-and-units)\n *\n * @category Properties\n */\nexport class Scene extends ExtensibleProperty<IScene> {\n\tpublic declare propertyType: PropertyType.SCENE;\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.SCENE;\n\t}\n\n\tprotected getDefaults(): Nullable<IScene> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, { children: [] });\n\t}\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\t// Scene cannot be copied, only cloned. Copying is shallow, but nodes cannot have more than\n\t\t// one parent. Rather than leaving one of the two scenes without children, throw an error here.\n\t\tif (resolve === COPY_IDENTITY) throw new Error('Scene cannot be copied.');\n\t\treturn super.copy(other, resolve);\n\t}\n\n\t/** Adds a {@link Node} to the scene. */\n\tpublic addChild(node: Node): this {\n\t\t// Remove existing parent.\n\t\tif (node._parent) node._parent.removeChild(node);\n\n\t\t// Edge in graph.\n\t\tthis.addRef('children', node);\n\n\t\t// Set new parent.\n\t\t// TODO(cleanup): Avoid using $attributes here?\n\t\tnode._parent = this;\n\t\tconst childrenRefs = this[$attributes]['children'];\n\t\tconst ref = childrenRefs[childrenRefs.length - 1];\n\t\tref.addEventListener('dispose', () => (node._parent = null));\n\t\treturn this;\n\t}\n\n\t/** Removes a {@link Node} from the scene. */\n\tpublic removeChild(node: Node): this {\n\t\treturn this.removeRef('children', node);\n\t}\n\n\t/** Lists all root {@link Node}s in the scene. */\n\tpublic listChildren(): Node[] {\n\t\treturn this.listRefs('children');\n\t}\n\n\t/** Visits each {@link Node} in the scene, including descendants, top-down. */\n\tpublic traverse(fn: (node: Node) => void): this {\n\t\tfor (const node of this.listChildren()) node.traverse(fn);\n\t\treturn this;\n\t}\n}\n","import { BufferViewUsage, Nullable, PropertyType } from '../constants';\nimport { Accessor } from './accessor';\nimport { ExtensibleProperty, IExtensibleProperty } from './extensible-property';\nimport { Node } from './node';\n\ninterface ISkin extends IExtensibleProperty {\n\tskeleton: Node;\n\tinverseBindMatrices: Accessor;\n\tjoints: Node[];\n}\n\n/**\n * # Skin\n *\n * *Collection of {@link Node} joints and inverse bind matrices used with skinned {@link Mesh}\n * instances.*\n *\n * Reference\n * - [glTF → Skins](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#skins)\n *\n * @category Properties\n */\nexport class Skin extends ExtensibleProperty<ISkin> {\n\tpublic declare propertyType: PropertyType.SKIN;\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.SKIN;\n\t}\n\n\tprotected getDefaults(): Nullable<ISkin> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\tskeleton: null,\n\t\t\tinverseBindMatrices: null,\n\t\t\tjoints: [],\n\t\t});\n\t}\n\n\t/**\n\t * {@link Node} used as a skeleton root. The node must be the closest common root of the joints\n\t * hierarchy or a direct or indirect parent node of the closest common root.\n\t */\n\tpublic getSkeleton(): Node | null {\n\t\treturn this.getRef('skeleton');\n\t}\n\n\t/**\n\t * {@link Node} used as a skeleton root. The node must be the closest common root of the joints\n\t * hierarchy or a direct or indirect parent node of the closest common root.\n\t */\n\tpublic setSkeleton(skeleton: Node | null): this {\n\t\treturn this.setRef('skeleton', skeleton);\n\t}\n\n\t/**\n\t * {@link Accessor} containing the floating-point 4x4 inverse-bind matrices. The default is\n\t * that each matrix is a 4x4 identity matrix, which implies that inverse-bind matrices were\n\t * pre-applied.\n\t */\n\tpublic getInverseBindMatrices(): Accessor | null {\n\t\treturn this.getRef('inverseBindMatrices');\n\t}\n\n\t/**\n\t * {@link Accessor} containing the floating-point 4x4 inverse-bind matrices. The default is\n\t * that each matrix is a 4x4 identity matrix, which implies that inverse-bind matrices were\n\t * pre-applied.\n\t */\n\tpublic setInverseBindMatrices(inverseBindMatrices: Accessor | null): this {\n\t\treturn this.setRef('inverseBindMatrices', inverseBindMatrices, {\n\t\t\tusage: BufferViewUsage.INVERSE_BIND_MATRICES,\n\t\t});\n\t}\n\n\t/** Adds a joint {@link Node} to this {@link Skin}. */\n\tpublic addJoint(joint: Node): this {\n\t\treturn this.addRef('joints', joint);\n\t}\n\n\t/** Removes a joint {@link Node} from this {@link Skin}. */\n\tpublic removeJoint(joint: Node): this {\n\t\treturn this.removeRef('joints', joint);\n\t}\n\n\t/** Lists joints ({@link Node}s used as joints or bones) in this {@link Skin}. */\n\tpublic listJoints(): Node[] {\n\t\treturn this.listRefs('joints');\n\t}\n}\n","import { Nullable, PropertyType, vec2 } from '../constants';\nimport { BufferUtils, FileUtils, ImageUtils } from '../utils';\nimport { ExtensibleProperty, IExtensibleProperty } from './extensible-property';\n\ninterface ITexture extends IExtensibleProperty {\n\timage: Uint8Array | null;\n\tmimeType: string;\n\turi: string;\n}\n\n/**\n * # Texture\n *\n * *Texture, or images, referenced by {@link Material} properties.*\n *\n * Textures in glTF-Transform are a combination of glTF's `texture` and `image` properties, and\n * should be unique within a document, such that no other texture contains the same\n * {@link getImage}() data. Where duplicates may already exist, the `dedup({textures: true})`\n * transform can remove them. A {@link Document} with N texture properties will be exported to a\n * glTF file with N `image` properties, and the minimum number of `texture` properties necessary\n * for the materials that use it.\n *\n * For properties associated with a particular _use_ of a texture, see {@link TextureInfo}.\n *\n * Reference:\n * - [glTF → Textures](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#textures)\n * - [glTF → Images](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#images)\n *\n * @category Properties\n */\nexport class Texture extends ExtensibleProperty<ITexture> {\n\tpublic declare propertyType: PropertyType.TEXTURE;\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.TEXTURE;\n\t}\n\n\tprotected getDefaults(): Nullable<ITexture> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, { image: null, mimeType: '', uri: '' });\n\t}\n\n\t/**********************************************************************************************\n\t * MIME type / format.\n\t */\n\n\t/** Returns the MIME type for this texture ('image/jpeg' or 'image/png'). */\n\tpublic getMimeType(): string {\n\t\treturn this.get('mimeType') || ImageUtils.extensionToMimeType(FileUtils.extension(this.get('uri')));\n\t}\n\n\t/**\n\t * Sets the MIME type for this texture ('image/jpeg' or 'image/png'). If the texture does not\n\t * have a URI, a MIME type is required for correct export.\n\t */\n\tpublic setMimeType(mimeType: string): this {\n\t\treturn this.set('mimeType', mimeType);\n\t}\n\n\t/**********************************************************************************************\n\t * URI / filename.\n\t */\n\n\t/** Returns the URI (e.g. 'path/to/file.png') for this texture. */\n\tpublic getURI(): string {\n\t\treturn this.get('uri');\n\t}\n\n\t/**\n\t * Sets the URI (e.g. 'path/to/file.png') for this texture. If the texture does not have a MIME\n\t * type, a URI is required for correct export.\n\t */\n\tpublic setURI(uri: string): this {\n\t\tthis.set('uri', uri);\n\t\tthis.set('mimeType', ImageUtils.extensionToMimeType(FileUtils.extension(uri)));\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Image data.\n\t */\n\n\t/** Returns the raw image data for this texture. */\n\tpublic getImage(): Uint8Array | null {\n\t\treturn this.get('image');\n\t}\n\n\t/** Sets the raw image data for this texture. */\n\tpublic setImage(image: Uint8Array): this {\n\t\treturn this.set('image', BufferUtils.assertView(image));\n\t}\n\n\t/** Returns the size, in pixels, of this texture. */\n\tpublic getSize(): vec2 | null {\n\t\tconst image = this.get('image');\n\t\tif (!image) return null;\n\t\treturn ImageUtils.getSize(image, this.getMimeType());\n\t}\n}\n","import { Nullable, PropertyType, VERSION } from '../constants';\nimport { Extension } from '../extension';\nimport { Graph } from 'property-graph';\nimport { Accessor } from './accessor';\nimport { Animation } from './animation';\nimport { Buffer } from './buffer';\nimport { Camera } from './camera';\nimport { Material } from './material';\nimport { Mesh } from './mesh';\nimport { Node } from './node';\nimport { COPY_IDENTITY, Property } from './property';\nimport { Scene } from './scene';\nimport { Skin } from './skin';\nimport { Texture } from './texture';\nimport { ExtensibleProperty, IExtensibleProperty } from './extensible-property';\nimport { ExtensionProperty } from './extension-property';\n\ninterface IAsset {\n\tversion: string;\n\tminVersion?: string;\n\tgenerator?: string;\n\tcopyright?: string;\n\t[key: string]: unknown;\n}\n\ninterface IRoot extends IExtensibleProperty {\n\tasset: IAsset;\n\tdefaultScene: Scene;\n\n\taccessors: Accessor[];\n\tanimations: Animation[];\n\tbuffers: Buffer[];\n\tcameras: Camera[];\n\tmaterials: Material[];\n\tmeshes: Mesh[];\n\tnodes: Node[];\n\tscenes: Scene[];\n\tskins: Skin[];\n\ttextures: Texture[];\n}\n\n/**\n * # Root\n *\n * *Root property of a glTF asset.*\n *\n * Any properties to be exported with a particular asset must be referenced (directly or\n * indirectly) by the root. Metadata about the asset's license, generator, and glTF specification\n * version are stored in the asset, accessible with {@link .getAsset}().\n *\n * Properties are added to the root with factory methods on its {@link Document}, and removed by\n * calling {@link Property.dispose}() on the resource. Any properties that have been created but\n * not disposed will be included when calling the various `root.list*()` methods.\n *\n * A document's root cannot be removed, and no other root may be created. Unlike other\n * {@link Property} types, the `.dispose()`, `.detach()` methods have no useful function on a\n * Root property.\n *\n * Usage:\n *\n * ```ts\n * const root = document.getRoot();\n * const scene = document.createScene('myScene');\n * const node = document.createNode('myNode');\n * scene.addChild(node);\n *\n * console.log(root.listScenes()); // → [scene x 1]\n * ```\n *\n * Reference: [glTF → Concepts](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#concepts)\n *\n * @category Properties\n */\nexport class Root extends ExtensibleProperty<IRoot> {\n\tpublic declare propertyType: PropertyType.ROOT;\n\n\tprivate readonly _extensions: Set<Extension> = new Set();\n\n\tprotected init(): void {\n\t\tthis.propertyType = PropertyType.ROOT;\n\t}\n\n\tprotected getDefaults(): Nullable<IRoot> {\n\t\treturn Object.assign(super.getDefaults() as IExtensibleProperty, {\n\t\t\tasset: {\n\t\t\t\tgenerator: `glTF-Transform ${VERSION}`,\n\t\t\t\tversion: '2.0',\n\t\t\t},\n\t\t\tdefaultScene: null,\n\t\t\taccessors: [],\n\t\t\tanimations: [],\n\t\t\tbuffers: [],\n\t\t\tcameras: [],\n\t\t\tmaterials: [],\n\t\t\tmeshes: [],\n\t\t\tnodes: [],\n\t\t\tscenes: [],\n\t\t\tskins: [],\n\t\t\ttextures: [],\n\t\t});\n\t}\n\n\t/** @internal */\n\tconstructor(graph: Graph<Property>) {\n\t\tsuper(graph);\n\t\tgraph.addEventListener('node:create', (event) => {\n\t\t\tthis._addChildOfRoot(event.target as Property);\n\t\t});\n\t}\n\n\tpublic clone(): this {\n\t\tthrow new Error('Root cannot be cloned.');\n\t}\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\t// Root cannot be cloned in isolation: only with its Document. Extensions are managed by\n\t\t// the Document during cloning. The Root, and only the Root, should keep existing\n\t\t// references while copying to avoid overwriting during a merge.\n\t\tif (resolve === COPY_IDENTITY) throw new Error('Root cannot be copied.');\n\n\t\t// IMPORTANT: Root cannot call super.copy(), which removes existing references.\n\n\t\tthis.set('asset', { ...other.get('asset') });\n\t\tthis.setName(other.getName());\n\t\tthis.setExtras({ ...other.getExtras() });\n\t\tthis.setDefaultScene(other.getDefaultScene() ? resolve(other.getDefaultScene()!) : null);\n\n\t\tfor (const extensionName of other.listRefMapKeys('extensions')) {\n\t\t\tconst otherExtension = other.getExtension(extensionName) as ExtensionProperty;\n\t\t\tthis.setExtension(extensionName, resolve(otherExtension));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprivate _addChildOfRoot(child: Property): this {\n\t\tif (child instanceof Scene) {\n\t\t\tthis.addRef('scenes', child);\n\t\t} else if (child instanceof Node) {\n\t\t\tthis.addRef('nodes', child);\n\t\t} else if (child instanceof Camera) {\n\t\t\tthis.addRef('cameras', child);\n\t\t} else if (child instanceof Skin) {\n\t\t\tthis.addRef('skins', child);\n\t\t} else if (child instanceof Mesh) {\n\t\t\tthis.addRef('meshes', child);\n\t\t} else if (child instanceof Material) {\n\t\t\tthis.addRef('materials', child);\n\t\t} else if (child instanceof Texture) {\n\t\t\tthis.addRef('textures', child);\n\t\t} else if (child instanceof Animation) {\n\t\t\tthis.addRef('animations', child);\n\t\t} else if (child instanceof Accessor) {\n\t\t\tthis.addRef('accessors', child);\n\t\t} else if (child instanceof Buffer) {\n\t\t\tthis.addRef('buffers', child);\n\t\t}\n\t\t// No error for untracked property types.\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the `asset` object, which specifies the target glTF version of the asset. Additional\n\t * metadata can be stored in optional properties such as `generator` or `copyright`.\n\t *\n\t * Reference: [glTF → Asset](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#asset)\n\t */\n\tpublic getAsset(): IAsset {\n\t\treturn this.get('asset');\n\t}\n\n\t/**********************************************************************************************\n\t * Extensions.\n\t */\n\n\t/** Lists all {@link Extension} properties enabled for this root. */\n\tpublic listExtensionsUsed(): Extension[] {\n\t\treturn Array.from(this._extensions);\n\t}\n\n\t/** Lists all {@link Extension} properties enabled and required for this root. */\n\tpublic listExtensionsRequired(): Extension[] {\n\t\treturn this.listExtensionsUsed().filter((extension) => extension.isRequired());\n\t}\n\n\t/** @internal */\n\tpublic _enableExtension(extension: Extension): this {\n\t\tthis._extensions.add(extension);\n\t\treturn this;\n\t}\n\n\t/** @internal */\n\tpublic _disableExtension(extension: Extension): this {\n\t\tthis._extensions.delete(extension);\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Properties.\n\t */\n\n\t/** Lists all {@link Scene} properties associated with this root. */\n\tpublic listScenes(): Scene[] {\n\t\treturn this.listRefs('scenes');\n\t}\n\n\t/** Default {@link Scene} associated with this root. */\n\tpublic setDefaultScene(defaultScene: Scene | null): this {\n\t\treturn this.setRef('defaultScene', defaultScene);\n\t}\n\n\t/** Default {@link Scene} associated with this root. */\n\tpublic getDefaultScene(): Scene | null {\n\t\treturn this.getRef('defaultScene');\n\t}\n\n\t/** Lists all {@link Node} properties associated with this root. */\n\tpublic listNodes(): Node[] {\n\t\treturn this.listRefs('nodes');\n\t}\n\n\t/** Lists all {@link Camera} properties associated with this root. */\n\tpublic listCameras(): Camera[] {\n\t\treturn this.listRefs('cameras');\n\t}\n\n\t/** Lists all {@link Skin} properties associated with this root. */\n\tpublic listSkins(): Skin[] {\n\t\treturn this.listRefs('skins');\n\t}\n\n\t/** Lists all {@link Mesh} properties associated with this root. */\n\tpublic listMeshes(): Mesh[] {\n\t\treturn this.listRefs('meshes');\n\t}\n\n\t/** Lists all {@link Material} properties associated with this root. */\n\tpublic listMaterials(): Material[] {\n\t\treturn this.listRefs('materials');\n\t}\n\n\t/** Lists all {@link Texture} properties associated with this root. */\n\tpublic listTextures(): Texture[] {\n\t\treturn this.listRefs('textures');\n\t}\n\n\t/** Lists all {@link Animation} properties associated with this root. */\n\tpublic listAnimations(): Animation[] {\n\t\treturn this.listRefs('animations');\n\t}\n\n\t/** Lists all {@link Accessor} properties associated with this root. */\n\tpublic listAccessors(): Accessor[] {\n\t\treturn this.listRefs('accessors');\n\t}\n\n\t/** Lists all {@link Buffer} properties associated with this root. */\n\tpublic listBuffers(): Buffer[] {\n\t\treturn this.listRefs('buffers');\n\t}\n}\n","import { PropertyType } from './constants';\nimport { Extension } from './extension';\nimport { Graph } from 'property-graph';\nimport {\n\tAccessor,\n\tAnimation,\n\tAnimationChannel,\n\tAnimationSampler,\n\tBuffer,\n\tCamera,\n\tMaterial,\n\tMesh,\n\tNode,\n\tPrimitive,\n\tPrimitiveTarget,\n\tProperty,\n\tRoot,\n\tScene,\n\tSkin,\n\tTexture,\n} from './properties';\nimport { Logger } from './utils';\n\nexport interface TransformContext {\n\tstack: string[];\n}\n\nexport type Transform = (doc: Document, context?: TransformContext) => void;\n\n/**\n * # Document\n *\n * *Wraps a glTF asset and its resources for easier modification.*\n *\n * Documents manage glTF assets and the relationships among dependencies. The document wrapper\n * allow tools to read and write changes without dealing with array indices or byte offsets, which\n * would otherwise require careful management over the course of a file modification. An internal\n * graph structure allows any property in the glTF file to maintain references to its dependencies,\n * and makes it easy to determine where a particular property dependency is being used. For\n * example, finding a list of materials that use a particular texture is as simple as calling\n * {@link Texture.listParents}().\n *\n * A new resource {@link Property} (e.g. a {@link Mesh} or {@link Material}) is created by calling\n * 'create' methods on the document. Resources are destroyed by calling {@link Property.dispose}().\n *\n * ```ts\n * import fs from 'fs/promises';\n * import { Document } from '@gltf-transform/core';\n * import { dedup } from '@gltf-transform/functions';\n *\n * const doc = new Document();\n *\n * const texture1 = doc.createTexture('myTexture')\n * \t.setImage(await fs.readFile('path/to/image.png'))\n * \t.setMimeType('image/png');\n * const texture2 = doc.createTexture('myTexture2')\n * \t.setImage(await fs.readFile('path/to/image2.png'))\n * \t.setMimeType('image/png');\n *\n * // Document containing duplicate copies of the same texture.\n * doc.getRoot().listTextures(); // → [texture x 2]\n *\n * await doc.transform(\n * \tdedup({textures: true}),\n * \t// ...\n * );\n *\n * // Document with duplicate textures removed.\n * doc.getRoot().listTextures(); // → [texture x 1]\n * ```\n *\n * Reference:\n * - [glTF → Basics](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#gltf-basics)\n * - [glTF → Concepts](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#concepts)\n *\n * @category Documents\n */\nexport class Document {\n\tprivate _graph: Graph<Property> = new Graph<Property>();\n\tprivate _root: Root = new Root(this._graph);\n\tprivate _logger = Logger.DEFAULT_INSTANCE;\n\n\t/** Returns the glTF {@link Root} property. */\n\tpublic getRoot(): Root {\n\t\treturn this._root;\n\t}\n\n\t/**\n\t * Returns the {@link Graph} representing connectivity of resources within this document.\n\t *\n\t * @hidden\n\t */\n\tpublic getGraph(): Graph<Property> {\n\t\treturn this._graph;\n\t}\n\n\t/** Returns the {@link Logger} instance used for any operations performed on this document. */\n\tpublic getLogger(): Logger {\n\t\treturn this._logger;\n\t}\n\n\t/**\n\t * Overrides the {@link Logger} instance used for any operations performed on this document.\n\t *\n\t * Usage:\n\t *\n\t * ```ts\n\t * doc\n\t * \t.setLogger(new Logger(Logger.Verbosity.SILENT))\n\t * \t.transform(dedup(), weld());\n\t * ```\n\t */\n\tpublic setLogger(logger: Logger): Document {\n\t\tthis._logger = logger;\n\t\treturn this;\n\t}\n\n\t/** Clones this Document, copying all resources within it. */\n\tpublic clone(): Document {\n\t\treturn new Document().setLogger(this._logger).merge(this);\n\t}\n\n\t/** Merges the content of another Document into this one, without affecting the original. */\n\tpublic merge(other: Document): this {\n\t\t// 1. Attach extensions.\n\t\tconst thisExtensions: { [key: string]: Extension } = {};\n\t\tfor (const otherExtension of other.getRoot().listExtensionsUsed()) {\n\t\t\tconst thisExtension = this.createExtension(otherExtension.constructor as new (doc: Document) => Extension);\n\t\t\tif (otherExtension.isRequired()) thisExtension.setRequired(true);\n\t\t\tthisExtensions[thisExtension.extensionName] = thisExtension;\n\t\t}\n\n\t\t// 2. Preconfigure the Root and merge history.\n\t\tconst visited = new Set<Property>();\n\t\tconst propertyMap = new Map<Property, Property>();\n\t\tvisited.add(other._root);\n\t\tpropertyMap.set(other._root, this._root);\n\n\t\t// 3. Create stub classes for every Property in other Document.\n\t\tfor (const edge of other._graph.listEdges()) {\n\t\t\tfor (const thisProp of [edge.getParent() as Property, edge.getChild() as Property]) {\n\t\t\t\tif (visited.has(thisProp)) continue;\n\n\t\t\t\tlet otherProp: Property;\n\t\t\t\tif (thisProp.propertyType === PropertyType.TEXTURE_INFO) {\n\t\t\t\t\t// TextureInfo lifecycle is bound to a Material or ExtensionProperty.\n\t\t\t\t\totherProp = thisProp as Property;\n\t\t\t\t} else {\n\t\t\t\t\t// For other property types, create stub classes.\n\t\t\t\t\tconst PropertyClass = thisProp.constructor as new (g: Graph<Property>) => Property;\n\t\t\t\t\totherProp = new PropertyClass(this._graph);\n\t\t\t\t}\n\n\t\t\t\tpropertyMap.set(thisProp as Property, otherProp);\n\t\t\t\tvisited.add(thisProp);\n\t\t\t}\n\t\t}\n\n\t\t// 4. Assemble the edges between Properties.\n\t\tconst resolve = (p: Property): Property => {\n\t\t\tconst resolved = propertyMap.get(p);\n\t\t\tif (!resolved) throw new Error('Could resolve property.');\n\t\t\treturn resolved;\n\t\t};\n\t\tfor (const otherProp of visited) {\n\t\t\tconst thisProp = propertyMap.get(otherProp);\n\t\t\tif (!thisProp) throw new Error('Could resolve property.');\n\t\t\tthisProp.copy(otherProp, resolve);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Applies a series of modifications to this document. Each transformation is asynchronous,\n\t * takes the {@link Document} as input, and returns nothing. Transforms are applied in the\n\t * order given, which may affect the final result.\n\t *\n\t * Usage:\n\t *\n\t * ```ts\n\t * await doc.transform(\n\t * \tdedup(),\n\t * \tprune()\n\t * );\n\t * ```\n\t *\n\t * @param transforms List of synchronous transformation functions to apply.\n\t */\n\tpublic async transform(...transforms: Transform[]): Promise<this> {\n\t\tconst stack = transforms.map((fn) => fn.name);\n\t\tfor (const transform of transforms) {\n\t\t\tawait transform(this, { stack });\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Extension factory method.\n\t */\n\n\t/**\n\t * Creates a new {@link Extension}, for the extension type of the given constructor. If the\n\t * extension is already enabled for this Document, the previous Extension reference is reused.\n\t */\n\tcreateExtension<T extends Extension>(ctor: new (doc: Document) => T): T {\n\t\tconst extensionName = (ctor as unknown as { EXTENSION_NAME: 'string' }).EXTENSION_NAME;\n\t\tconst prevExtension = this.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.find((ext) => ext.extensionName === extensionName);\n\t\treturn (prevExtension || new ctor(this)) as T;\n\t}\n\n\t/**********************************************************************************************\n\t * Property factory methods.\n\t */\n\n\t/** Creates a new {@link Scene} attached to this document's {@link Root}. */\n\tcreateScene(name = ''): Scene {\n\t\treturn new Scene(this._graph, name);\n\t}\n\n\t/** Creates a new {@link Node} attached to this document's {@link Root}. */\n\tcreateNode(name = ''): Node {\n\t\treturn new Node(this._graph, name);\n\t}\n\n\t/** Creates a new {@link Camera} attached to this document's {@link Root}. */\n\tcreateCamera(name = ''): Camera {\n\t\treturn new Camera(this._graph, name);\n\t}\n\n\t/** Creates a new {@link Skin} attached to this document's {@link Root}. */\n\tcreateSkin(name = ''): Skin {\n\t\treturn new Skin(this._graph, name);\n\t}\n\n\t/** Creates a new {@link Mesh} attached to this document's {@link Root}. */\n\tcreateMesh(name = ''): Mesh {\n\t\treturn new Mesh(this._graph, name);\n\t}\n\n\t/**\n\t * Creates a new {@link Primitive}. Primitives must be attached to a {@link Mesh}\n\t * for use and export; they are not otherwise associated with a {@link Root}.\n\t */\n\tcreatePrimitive(): Primitive {\n\t\treturn new Primitive(this._graph);\n\t}\n\n\t/**\n\t * Creates a new {@link PrimitiveTarget}, or morph target. Targets must be attached to a\n\t * {@link Primitive} for use and export; they are not otherwise associated with a {@link Root}.\n\t */\n\tcreatePrimitiveTarget(name = ''): PrimitiveTarget {\n\t\treturn new PrimitiveTarget(this._graph, name);\n\t}\n\n\t/** Creates a new {@link Material} attached to this document's {@link Root}. */\n\tcreateMaterial(name = ''): Material {\n\t\treturn new Material(this._graph, name);\n\t}\n\n\t/** Creates a new {@link Texture} attached to this document's {@link Root}. */\n\tcreateTexture(name = ''): Texture {\n\t\treturn new Texture(this._graph, name);\n\t}\n\n\t/** Creates a new {@link Animation} attached to this document's {@link Root}. */\n\tcreateAnimation(name = ''): Animation {\n\t\treturn new Animation(this._graph, name);\n\t}\n\n\t/**\n\t * Creates a new {@link AnimationChannel}. Channels must be attached to an {@link Animation}\n\t * for use and export; they are not otherwise associated with a {@link Root}.\n\t */\n\tcreateAnimationChannel(name = ''): AnimationChannel {\n\t\treturn new AnimationChannel(this._graph, name);\n\t}\n\n\t/**\n\t * Creates a new {@link AnimationSampler}. Samplers must be attached to an {@link Animation}\n\t * for use and export; they are not otherwise associated with a {@link Root}.\n\t */\n\tcreateAnimationSampler(name = ''): AnimationSampler {\n\t\treturn new AnimationSampler(this._graph, name);\n\t}\n\n\t/** Creates a new {@link Accessor} attached to this document's {@link Root}. */\n\tcreateAccessor(name = '', buffer: Buffer | null = null): Accessor {\n\t\tif (!buffer) {\n\t\t\tbuffer = this.getRoot().listBuffers()[0];\n\t\t}\n\t\treturn new Accessor(this._graph, name).setBuffer(buffer);\n\t}\n\n\t/** Creates a new {@link Buffer} attached to this document's {@link Root}. */\n\tcreateBuffer(name = ''): Buffer {\n\t\treturn new Buffer(this._graph, name);\n\t}\n}\n","import { GraphEdgeEvent, GraphEvent, GraphNodeEvent } from 'property-graph';\nimport { PropertyType } from './constants';\nimport { Document } from './document';\nimport { ReaderContext, WriterContext } from './io';\nimport { ExtensionProperty } from './properties';\n\n/**\n * # Extension\n *\n * *Base class for all Extensions.*\n *\n * Extensions enhance a glTF {@link Document} with additional features and schema, beyond the core\n * glTF specification. Common extensions may be imported from the `@gltf-transform/extensions`\n * package, or custom extensions may be created by extending this base class.\n *\n * An extension is added to a Document by calling {@link Document.createExtension} with the\n * extension constructor. The extension object may then be used to construct\n * {@link ExtensionProperty} instances, which are attached to properties throughout the Document\n * as prescribed by the extension itself.\n *\n * For more information on available extensions and their usage, see [Extensions](/extensions).\n *\n * Reference:\n * - [glTF → Extensions](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#specifying-extensions)\n * - [glTF Extension Registry](https://github.com/KhronosGroup/glTF/blob/master/extensions)\n *\n * @category Extensions\n */\nexport abstract class Extension {\n\t/** Official name of the extension. */\n\tpublic static EXTENSION_NAME: string;\n\t/** Official name of the extension. */\n\tpublic readonly extensionName: string = '';\n\t/**\n\t * Before reading, extension should be called for these {@link Property} types. *Most\n\t * extensions don't need to implement this.*\n\t * @hidden\n\t */\n\tpublic readonly prereadTypes: PropertyType[] = [];\n\t/**\n\t * Before writing, extension should be called for these {@link Property} types. *Most\n\t * extensions don't need to implement this.*\n\t * @hidden\n\t */\n\tpublic readonly prewriteTypes: PropertyType[] = [];\n\n\t/** @hidden Dependency IDs needed to read this extension, to be installed before I/O. */\n\tpublic readonly readDependencies: string[] = [];\n\t/** @hidden Dependency IDs needed to write this extension, to be installed before I/O. */\n\tpublic readonly writeDependencies: string[] = [];\n\n\t/** @hidden */\n\tprotected readonly document: Document;\n\n\t/** @hidden */\n\tprotected required = false;\n\n\t/** @hidden */\n\tprotected properties: Set<ExtensionProperty> = new Set();\n\n\t/** @hidden */\n\tprivate _listener: (event: unknown) => void;\n\n\t/** @hidden */\n\tconstructor(document: Document) {\n\t\tthis.document = document;\n\n\t\tdocument.getRoot()._enableExtension(this);\n\n\t\tthis._listener = (_event: unknown): void => {\n\t\t\tconst event = _event as GraphNodeEvent | GraphEdgeEvent | GraphEvent;\n\t\t\tconst target = event.target as ExtensionProperty | unknown;\n\t\t\tif (target instanceof ExtensionProperty && target.extensionName === this.extensionName) {\n\t\t\t\tif (event.type === 'node:create') this._addExtensionProperty(target);\n\t\t\t\tif (event.type === 'node:dispose') this._removeExtensionProperty(target);\n\t\t\t}\n\t\t};\n\n\t\tconst graph = document.getGraph();\n\t\tgraph.addEventListener('node:create', this._listener);\n\t\tgraph.addEventListener('node:dispose', this._listener);\n\t}\n\n\t/** Disables and removes the extension from the Document. */\n\tpublic dispose(): void {\n\t\tthis.document.getRoot()._disableExtension(this);\n\t\tconst graph = this.document.getGraph();\n\t\tgraph.removeEventListener('node:create', this._listener);\n\t\tgraph.removeEventListener('node:dispose', this._listener);\n\t\tfor (const property of this.properties) {\n\t\t\tproperty.dispose();\n\t\t}\n\t}\n\n\t/** @hidden Performs first-time setup for the extension. Must be idempotent. */\n\t// eslint-disable-next-line @typescript-eslint/no-empty-function\n\tpublic static register(): void {}\n\n\t/**\n\t * Indicates to the client whether it is OK to load the asset when this extension is not\n\t * recognized. Optional extensions are generally preferred, if there is not a good reason\n\t * to require a client to completely fail when an extension isn't known.\n\t */\n\tpublic isRequired(): boolean {\n\t\treturn this.required;\n\t}\n\n\t/**\n\t * Indicates to the client whether it is OK to load the asset when this extension is not\n\t * recognized. Optional extensions are generally preferred, if there is not a good reason\n\t * to require a client to completely fail when an extension isn't known.\n\t */\n\tpublic setRequired(required: boolean): this {\n\t\tthis.required = required;\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * ExtensionProperty management.\n\t */\n\n\t/** @internal */\n\tprivate _addExtensionProperty(property: ExtensionProperty): this {\n\t\tthis.properties.add(property);\n\t\treturn this;\n\t}\n\n\t/** @internal */\n\tprivate _removeExtensionProperty(property: ExtensionProperty): this {\n\t\tthis.properties.delete(property);\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * I/O implementation.\n\t */\n\n\t/** @hidden Installs dependencies required by the extension. */\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tpublic install(key: string, dependency: unknown): this {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Used by the {@link PlatformIO} utilities when reading a glTF asset. This method may\n\t * optionally be implemented by an extension, and should then support any property type\n\t * declared by the Extension's {@link Extension.prereadTypes} list. The Extension will\n\t * be given a ReaderContext instance, and is expected to update either the context or its\n\t * {@link JSONDocument} with resources known to the Extension. *Most extensions don't need to\n\t * implement this.*\n\t * @hidden\n\t */\n\tpublic preread(_readerContext: ReaderContext, _propertyType: PropertyType): this {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Used by the {@link PlatformIO} utilities when writing a glTF asset. This method may\n\t * optionally be implemented by an extension, and should then support any property type\n\t * declared by the Extension's {@link Extension.prewriteTypes} list. The Extension will\n\t * be given a WriterContext instance, and is expected to update either the context or its\n\t * {@link JSONDocument} with resources known to the Extension. *Most extensions don't need to\n\t * implement this.*\n\t * @hidden\n\t */\n\tpublic prewrite(_writerContext: WriterContext, _propertyType: PropertyType): this {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Used by the {@link PlatformIO} utilities when reading a glTF asset. This method must be\n\t * implemented by each extension in order to support reading files. The extension will be\n\t * given a ReaderContext instance, and should update the current {@link Document} accordingly.\n\t * @hidden\n\t */\n\tpublic abstract read(readerContext: ReaderContext): this;\n\n\t/**\n\t * Used by the {@link PlatformIO} utilities when writing a glTF asset. This method must be\n\t * implemented by each extension in order to support writing files. The extension will be\n\t * given a WriterContext instance, and should modify the {@link JSONDocument} output\n\t * accordingly. Adding the extension name to the `extensionsUsed` and `extensionsRequired` list\n\t * is done automatically, and should not be included here.\n\t * @hidden\n\t */\n\tpublic abstract write(writerContext: WriterContext): this;\n}\n","import { JSONDocument } from '../json-document';\nimport {\n\tAccessor,\n\tAnimation,\n\tBuffer,\n\tCamera,\n\tMaterial,\n\tMesh,\n\tNode,\n\tScene,\n\tSkin,\n\tTexture,\n\tTextureInfo,\n} from '../properties';\nimport { GLTF } from '../types/gltf';\n\n/**\n * Model class providing glTF-Transform objects representing each definition in the glTF file, used\n * by a {@link Writer} and its {@link Extension} implementations. Indices of all properties will be\n * consistent with the glTF file.\n *\n * @hidden\n */\nexport class ReaderContext {\n\tpublic buffers: Buffer[] = [];\n\tpublic bufferViews: Uint8Array[] = [];\n\tpublic bufferViewBuffers: Buffer[] = [];\n\tpublic accessors: Accessor[] = [];\n\tpublic textures: Texture[] = [];\n\tpublic textureInfos: Map<TextureInfo, GLTF.ITextureInfo> = new Map();\n\tpublic materials: Material[] = [];\n\tpublic meshes: Mesh[] = [];\n\tpublic cameras: Camera[] = [];\n\tpublic nodes: Node[] = [];\n\tpublic skins: Skin[] = [];\n\tpublic animations: Animation[] = [];\n\tpublic scenes: Scene[] = [];\n\n\tconstructor(public readonly jsonDoc: JSONDocument) {}\n\n\tpublic setTextureInfo(textureInfo: TextureInfo, textureInfoDef: GLTF.ITextureInfo): void {\n\t\tthis.textureInfos.set(textureInfo, textureInfoDef);\n\n\t\tif (textureInfoDef.texCoord !== undefined) {\n\t\t\ttextureInfo.setTexCoord(textureInfoDef.texCoord);\n\t\t}\n\n\t\tconst textureDef = this.jsonDoc.json.textures![textureInfoDef.index];\n\n\t\tif (textureDef.sampler === undefined) return;\n\n\t\tconst samplerDef = this.jsonDoc.json.samplers![textureDef.sampler];\n\n\t\tif (samplerDef.magFilter !== undefined) {\n\t\t\ttextureInfo.setMagFilter(samplerDef.magFilter);\n\t\t}\n\t\tif (samplerDef.minFilter !== undefined) {\n\t\t\ttextureInfo.setMinFilter(samplerDef.minFilter);\n\t\t}\n\t\tif (samplerDef.wrapS !== undefined) {\n\t\t\ttextureInfo.setWrapS(samplerDef.wrapS);\n\t\t}\n\t\tif (samplerDef.wrapT !== undefined) {\n\t\t\ttextureInfo.setWrapT(samplerDef.wrapT);\n\t\t}\n\t}\n}\n","import { GLB_BUFFER, PropertyType, TypedArray, mat4, vec3, vec4 } from '../constants';\nimport { Document } from '../document';\nimport { Extension } from '../extension';\nimport { JSONDocument } from '../json-document';\nimport { Accessor, AnimationSampler, Camera } from '../properties';\nimport { GLTF } from '../types/gltf';\nimport { BufferUtils, FileUtils, ImageUtils, Logger, MathUtils } from '../utils';\nimport { ReaderContext } from './reader-context';\n\nconst ComponentTypeToTypedArray = {\n\t'5120': Int8Array,\n\t'5121': Uint8Array,\n\t'5122': Int16Array,\n\t'5123': Uint16Array,\n\t'5125': Uint32Array,\n\t'5126': Float32Array,\n};\n\nexport interface ReaderOptions {\n\tlogger?: Logger;\n\textensions: typeof Extension[];\n\tdependencies: { [key: string]: unknown };\n}\n\nconst DEFAULT_OPTIONS: ReaderOptions = {\n\tlogger: Logger.DEFAULT_INSTANCE,\n\textensions: [],\n\tdependencies: {},\n};\n\n/** @internal */\nexport class GLTFReader {\n\tpublic static read(jsonDoc: JSONDocument, _options: ReaderOptions = DEFAULT_OPTIONS): Document {\n\t\tconst options = { ...DEFAULT_OPTIONS, ..._options } as Required<ReaderOptions>;\n\t\tconst { json } = jsonDoc;\n\t\tconst doc = new Document();\n\n\t\tthis.validate(jsonDoc, options);\n\n\t\t/* Reader context. */\n\n\t\tconst context = new ReaderContext(jsonDoc);\n\n\t\t/** Asset. */\n\n\t\tconst assetDef = json.asset;\n\t\tconst asset = doc.getRoot().getAsset();\n\n\t\tif (assetDef.copyright) asset.copyright = assetDef.copyright;\n\t\tif (assetDef.extras) asset.extras = assetDef.extras;\n\n\t\tif (json.extras !== undefined) {\n\t\t\tdoc.getRoot().setExtras({ ...json.extras });\n\t\t}\n\n\t\t/** Extensions (1/2). */\n\n\t\tconst extensionsUsed = json.extensionsUsed || [];\n\t\tconst extensionsRequired = json.extensionsRequired || [];\n\t\tfor (const Extension of options.extensions) {\n\t\t\tif (extensionsUsed.includes(Extension.EXTENSION_NAME)) {\n\t\t\t\tconst extension = doc\n\t\t\t\t\t.createExtension(Extension as unknown as new (doc: Document) => Extension)\n\t\t\t\t\t.setRequired(extensionsRequired.includes(Extension.EXTENSION_NAME));\n\n\t\t\t\tfor (const key of extension.readDependencies) {\n\t\t\t\t\textension.install(key, options.dependencies[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/** Buffers. */\n\n\t\tconst bufferDefs = json.buffers || [];\n\t\tdoc.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.filter((extension) => extension.prereadTypes.includes(PropertyType.BUFFER))\n\t\t\t.forEach((extension) => extension.preread(context, PropertyType.BUFFER));\n\t\tcontext.buffers = bufferDefs.map((bufferDef) => {\n\t\t\tconst buffer = doc.createBuffer(bufferDef.name);\n\n\t\t\tif (bufferDef.extras) buffer.setExtras(bufferDef.extras);\n\n\t\t\tif (bufferDef.uri && bufferDef.uri.indexOf('__') !== 0) {\n\t\t\t\tbuffer.setURI(bufferDef.uri);\n\t\t\t}\n\n\t\t\treturn buffer;\n\t\t});\n\n\t\t/** Buffer views. */\n\n\t\tconst bufferViewDefs = json.bufferViews || [];\n\t\tcontext.bufferViewBuffers = bufferViewDefs.map((bufferViewDef, index) => {\n\t\t\tif (!context.bufferViews[index]) {\n\t\t\t\tconst bufferDef = jsonDoc.json.buffers![bufferViewDef.buffer];\n\t\t\t\tconst resource = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];\n\t\t\t\tconst byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\t\tcontext.bufferViews[index] = BufferUtils.toView(resource, byteOffset, bufferViewDef.byteLength);\n\t\t\t}\n\n\t\t\treturn context.buffers[bufferViewDef.buffer];\n\t\t});\n\n\t\t/** Accessors. */\n\n\t\t// Accessor .count and .componentType properties are inferred dynamically.\n\t\tconst accessorDefs = json.accessors || [];\n\t\tcontext.accessors = accessorDefs.map((accessorDef) => {\n\t\t\tconst buffer = context.bufferViewBuffers[accessorDef.bufferView!];\n\t\t\tconst accessor = doc.createAccessor(accessorDef.name, buffer).setType(accessorDef.type);\n\n\t\t\tif (accessorDef.extras) accessor.setExtras(accessorDef.extras);\n\n\t\t\tif (accessorDef.normalized !== undefined) {\n\t\t\t\taccessor.setNormalized(accessorDef.normalized);\n\t\t\t}\n\n\t\t\t// KHR_draco_mesh_compression and EXT_meshopt_compression.\n\t\t\tif (accessorDef.bufferView === undefined && !accessorDef.sparse) return accessor;\n\n\t\t\tlet array: TypedArray;\n\n\t\t\tif (accessorDef.sparse !== undefined) {\n\t\t\t\tarray = getSparseArray(accessorDef, context);\n\t\t\t} else {\n\t\t\t\tarray = getAccessorArray(accessorDef, context);\n\t\t\t}\n\n\t\t\taccessor.setArray(array);\n\t\t\treturn accessor;\n\t\t});\n\n\t\t/** Textures. */\n\n\t\t// glTF-Transform's \"Texture\" properties correspond 1:1 with glTF \"Image\" properties, and\n\t\t// with image files. The glTF file may contain more one texture per image, where images\n\t\t// are reused with different sampler properties.\n\t\tconst imageDefs = json.images || [];\n\t\tconst textureDefs = json.textures || [];\n\t\tdoc.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.filter((extension) => extension.prereadTypes.includes(PropertyType.TEXTURE))\n\t\t\t.forEach((extension) => extension.preread(context, PropertyType.TEXTURE));\n\t\tcontext.textures = imageDefs.map((imageDef) => {\n\t\t\tconst texture = doc.createTexture(imageDef.name);\n\n\t\t\t// glTF Image corresponds 1:1 with glTF-Transform Texture. See `writer.ts`.\n\t\t\tif (imageDef.extras) texture.setExtras(imageDef.extras);\n\n\t\t\tif (imageDef.bufferView !== undefined) {\n\t\t\t\tconst bufferViewDef = json.bufferViews![imageDef.bufferView];\n\t\t\t\tconst bufferDef = jsonDoc.json.buffers![bufferViewDef.buffer];\n\t\t\t\tconst bufferData = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];\n\t\t\t\tconst byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\t\tconst byteLength = bufferViewDef.byteLength;\n\t\t\t\tconst imageData = bufferData.slice(byteOffset, byteOffset + byteLength);\n\t\t\t\ttexture.setImage(imageData);\n\t\t\t} else if (imageDef.uri !== undefined) {\n\t\t\t\ttexture.setImage(jsonDoc.resources[imageDef.uri]);\n\t\t\t\tif (imageDef.uri.indexOf('__') !== 0) {\n\t\t\t\t\ttexture.setURI(imageDef.uri);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (imageDef.mimeType !== undefined) {\n\t\t\t\ttexture.setMimeType(imageDef.mimeType);\n\t\t\t} else if (imageDef.uri) {\n\t\t\t\tconst extension = FileUtils.extension(imageDef.uri);\n\t\t\t\ttexture.setMimeType(ImageUtils.extensionToMimeType(extension));\n\t\t\t}\n\n\t\t\treturn texture;\n\t\t});\n\n\t\t/** Materials. */\n\n\t\tconst materialDefs = json.materials || [];\n\t\tcontext.materials = materialDefs.map((materialDef) => {\n\t\t\tconst material = doc.createMaterial(materialDef.name);\n\n\t\t\tif (materialDef.extras) material.setExtras(materialDef.extras);\n\n\t\t\t// Program state & blending.\n\n\t\t\tif (materialDef.alphaMode !== undefined) {\n\t\t\t\tmaterial.setAlphaMode(materialDef.alphaMode);\n\t\t\t}\n\n\t\t\tif (materialDef.alphaCutoff !== undefined) {\n\t\t\t\tmaterial.setAlphaCutoff(materialDef.alphaCutoff);\n\t\t\t}\n\n\t\t\tif (materialDef.doubleSided !== undefined) {\n\t\t\t\tmaterial.setDoubleSided(materialDef.doubleSided);\n\t\t\t}\n\n\t\t\t// Factors.\n\n\t\t\tconst pbrDef = materialDef.pbrMetallicRoughness || {};\n\n\t\t\tif (pbrDef.baseColorFactor !== undefined) {\n\t\t\t\tmaterial.setBaseColorFactor(pbrDef.baseColorFactor as vec4);\n\t\t\t}\n\n\t\t\tif (materialDef.emissiveFactor !== undefined) {\n\t\t\t\tmaterial.setEmissiveFactor(materialDef.emissiveFactor as vec3);\n\t\t\t}\n\n\t\t\tif (pbrDef.metallicFactor !== undefined) {\n\t\t\t\tmaterial.setMetallicFactor(pbrDef.metallicFactor);\n\t\t\t}\n\n\t\t\tif (pbrDef.roughnessFactor !== undefined) {\n\t\t\t\tmaterial.setRoughnessFactor(pbrDef.roughnessFactor);\n\t\t\t}\n\n\t\t\t// Textures.\n\n\t\t\tif (pbrDef.baseColorTexture !== undefined) {\n\t\t\t\tconst textureInfoDef = pbrDef.baseColorTexture;\n\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\tmaterial.setBaseColorTexture(texture);\n\t\t\t\tcontext.setTextureInfo(material.getBaseColorTextureInfo()!, textureInfoDef);\n\t\t\t}\n\n\t\t\tif (materialDef.emissiveTexture !== undefined) {\n\t\t\t\tconst textureInfoDef = materialDef.emissiveTexture;\n\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\tmaterial.setEmissiveTexture(texture);\n\t\t\t\tcontext.setTextureInfo(material.getEmissiveTextureInfo()!, textureInfoDef);\n\t\t\t}\n\n\t\t\tif (materialDef.normalTexture !== undefined) {\n\t\t\t\tconst textureInfoDef = materialDef.normalTexture;\n\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\tmaterial.setNormalTexture(texture);\n\t\t\t\tcontext.setTextureInfo(material.getNormalTextureInfo()!, textureInfoDef);\n\t\t\t\tif (materialDef.normalTexture.scale !== undefined) {\n\t\t\t\t\tmaterial.setNormalScale(materialDef.normalTexture.scale);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (materialDef.occlusionTexture !== undefined) {\n\t\t\t\tconst textureInfoDef = materialDef.occlusionTexture;\n\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\tmaterial.setOcclusionTexture(texture);\n\t\t\t\tcontext.setTextureInfo(material.getOcclusionTextureInfo()!, textureInfoDef);\n\t\t\t\tif (materialDef.occlusionTexture.strength !== undefined) {\n\t\t\t\t\tmaterial.setOcclusionStrength(materialDef.occlusionTexture.strength);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (pbrDef.metallicRoughnessTexture !== undefined) {\n\t\t\t\tconst textureInfoDef = pbrDef.metallicRoughnessTexture;\n\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\tmaterial.setMetallicRoughnessTexture(texture);\n\t\t\t\tcontext.setTextureInfo(material.getMetallicRoughnessTextureInfo()!, textureInfoDef);\n\t\t\t}\n\n\t\t\treturn material;\n\t\t});\n\n\t\t/** Meshes. */\n\n\t\tconst meshDefs = json.meshes || [];\n\t\tdoc.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.filter((extension) => extension.prereadTypes.includes(PropertyType.PRIMITIVE))\n\t\t\t.forEach((extension) => extension.preread(context, PropertyType.PRIMITIVE));\n\t\tcontext.meshes = meshDefs.map((meshDef) => {\n\t\t\tconst mesh = doc.createMesh(meshDef.name);\n\n\t\t\tif (meshDef.extras) mesh.setExtras(meshDef.extras);\n\n\t\t\tif (meshDef.weights !== undefined) {\n\t\t\t\tmesh.setWeights(meshDef.weights);\n\t\t\t}\n\n\t\t\tconst primitiveDefs = meshDef.primitives || [];\n\t\t\tprimitiveDefs.forEach((primitiveDef) => {\n\t\t\t\tconst primitive = doc.createPrimitive();\n\n\t\t\t\tif (primitiveDef.extras) primitive.setExtras(primitiveDef.extras);\n\n\t\t\t\tif (primitiveDef.material !== undefined) {\n\t\t\t\t\tprimitive.setMaterial(context.materials[primitiveDef.material]);\n\t\t\t\t}\n\n\t\t\t\tif (primitiveDef.mode !== undefined) {\n\t\t\t\t\tprimitive.setMode(primitiveDef.mode);\n\t\t\t\t}\n\n\t\t\t\tfor (const [semantic, index] of Object.entries(primitiveDef.attributes || {})) {\n\t\t\t\t\tprimitive.setAttribute(semantic, context.accessors[index]);\n\t\t\t\t}\n\n\t\t\t\tif (primitiveDef.indices !== undefined) {\n\t\t\t\t\tprimitive.setIndices(context.accessors[primitiveDef.indices]);\n\t\t\t\t}\n\n\t\t\t\tconst targetNames: string[] = (meshDef.extras && (meshDef.extras.targetNames as string[])) || [];\n\t\t\t\tconst targetDefs = primitiveDef.targets || [];\n\t\t\t\ttargetDefs.forEach((targetDef, targetIndex) => {\n\t\t\t\t\tconst targetName = targetNames[targetIndex] || targetIndex.toString();\n\t\t\t\t\tconst target = doc.createPrimitiveTarget(targetName);\n\n\t\t\t\t\tfor (const [semantic, accessorIndex] of Object.entries(targetDef)) {\n\t\t\t\t\t\ttarget.setAttribute(semantic, context.accessors[accessorIndex]);\n\t\t\t\t\t}\n\n\t\t\t\t\tprimitive.addTarget(target);\n\t\t\t\t});\n\n\t\t\t\tmesh.addPrimitive(primitive);\n\t\t\t});\n\n\t\t\treturn mesh;\n\t\t});\n\n\t\t/** Cameras. */\n\n\t\tconst cameraDefs = json.cameras || [];\n\t\tcontext.cameras = cameraDefs.map((cameraDef) => {\n\t\t\tconst camera = doc.createCamera(cameraDef.name).setType(cameraDef.type);\n\n\t\t\tif (cameraDef.extras) camera.setExtras(cameraDef.extras);\n\n\t\t\tif (cameraDef.type === Camera.Type.PERSPECTIVE) {\n\t\t\t\tconst perspectiveDef = cameraDef.perspective!;\n\t\t\t\tcamera.setYFov(perspectiveDef.yfov);\n\t\t\t\tcamera.setZNear(perspectiveDef.znear);\n\t\t\t\tif (perspectiveDef.zfar !== undefined) {\n\t\t\t\t\tcamera.setZFar(perspectiveDef.zfar);\n\t\t\t\t}\n\t\t\t\tif (perspectiveDef.aspectRatio !== undefined) {\n\t\t\t\t\tcamera.setAspectRatio(perspectiveDef.aspectRatio);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst orthoDef = cameraDef.orthographic!;\n\t\t\t\tcamera.setZNear(orthoDef.znear).setZFar(orthoDef.zfar).setXMag(orthoDef.xmag).setYMag(orthoDef.ymag);\n\t\t\t}\n\t\t\treturn camera;\n\t\t});\n\n\t\t/** Nodes. */\n\n\t\tconst nodeDefs = json.nodes || [];\n\n\t\tdoc.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.filter((extension) => extension.prereadTypes.includes(PropertyType.NODE))\n\t\t\t.forEach((extension) => extension.preread(context, PropertyType.NODE));\n\n\t\tcontext.nodes = nodeDefs.map((nodeDef) => {\n\t\t\tconst node = doc.createNode(nodeDef.name);\n\n\t\t\tif (nodeDef.extras) node.setExtras(nodeDef.extras);\n\n\t\t\tif (nodeDef.translation !== undefined) {\n\t\t\t\tnode.setTranslation(nodeDef.translation as vec3);\n\t\t\t}\n\n\t\t\tif (nodeDef.rotation !== undefined) {\n\t\t\t\tnode.setRotation(nodeDef.rotation as vec4);\n\t\t\t}\n\n\t\t\tif (nodeDef.scale !== undefined) {\n\t\t\t\tnode.setScale(nodeDef.scale as vec3);\n\t\t\t}\n\n\t\t\tif (nodeDef.matrix !== undefined) {\n\t\t\t\tconst translation = [0, 0, 0] as vec3;\n\t\t\t\tconst rotation = [0, 0, 0, 1] as vec4;\n\t\t\t\tconst scale = [1, 1, 1] as vec3;\n\n\t\t\t\tMathUtils.decompose(nodeDef.matrix as mat4, translation, rotation, scale);\n\n\t\t\t\tnode.setTranslation(translation);\n\t\t\t\tnode.setRotation(rotation);\n\t\t\t\tnode.setScale(scale);\n\t\t\t}\n\n\t\t\tif (nodeDef.weights !== undefined) {\n\t\t\t\tnode.setWeights(nodeDef.weights);\n\t\t\t}\n\n\t\t\t// Attachments (mesh, camera, skin) defined later in reading process.\n\n\t\t\treturn node;\n\t\t});\n\n\t\t/** Skins. */\n\n\t\tconst skinDefs = json.skins || [];\n\t\tcontext.skins = skinDefs.map((skinDef) => {\n\t\t\tconst skin = doc.createSkin(skinDef.name);\n\n\t\t\tif (skinDef.extras) skin.setExtras(skinDef.extras);\n\n\t\t\tif (skinDef.inverseBindMatrices !== undefined) {\n\t\t\t\tskin.setInverseBindMatrices(context.accessors[skinDef.inverseBindMatrices]);\n\t\t\t}\n\n\t\t\tif (skinDef.skeleton !== undefined) {\n\t\t\t\tskin.setSkeleton(context.nodes[skinDef.skeleton]);\n\t\t\t}\n\n\t\t\tfor (const nodeIndex of skinDef.joints) {\n\t\t\t\tskin.addJoint(context.nodes[nodeIndex]);\n\t\t\t}\n\n\t\t\treturn skin;\n\t\t});\n\n\t\t/** Node attachments. */\n\n\t\tnodeDefs.map((nodeDef, nodeIndex) => {\n\t\t\tconst node = context.nodes[nodeIndex];\n\n\t\t\tconst children = nodeDef.children || [];\n\t\t\tchildren.forEach((childIndex) => node.addChild(context.nodes[childIndex]));\n\n\t\t\tif (nodeDef.mesh !== undefined) node.setMesh(context.meshes[nodeDef.mesh]);\n\n\t\t\tif (nodeDef.camera !== undefined) node.setCamera(context.cameras[nodeDef.camera]);\n\n\t\t\tif (nodeDef.skin !== undefined) node.setSkin(context.skins[nodeDef.skin]);\n\t\t});\n\n\t\t/** Animations. */\n\n\t\tconst animationDefs = json.animations || [];\n\t\tcontext.animations = animationDefs.map((animationDef) => {\n\t\t\tconst animation = doc.createAnimation(animationDef.name);\n\n\t\t\tif (animationDef.extras) animation.setExtras(animationDef.extras);\n\n\t\t\tconst samplerDefs = animationDef.samplers || [];\n\t\t\tconst samplers = samplerDefs.map((samplerDef) => {\n\t\t\t\tconst sampler = doc\n\t\t\t\t\t.createAnimationSampler()\n\t\t\t\t\t.setInput(context.accessors[samplerDef.input])\n\t\t\t\t\t.setOutput(context.accessors[samplerDef.output])\n\t\t\t\t\t.setInterpolation(samplerDef.interpolation || AnimationSampler.Interpolation.LINEAR);\n\n\t\t\t\tif (samplerDef.extras) sampler.setExtras(samplerDef.extras);\n\n\t\t\t\tanimation.addSampler(sampler);\n\t\t\t\treturn sampler;\n\t\t\t});\n\n\t\t\tconst channels = animationDef.channels || [];\n\t\t\tchannels.forEach((channelDef) => {\n\t\t\t\tconst channel = doc\n\t\t\t\t\t.createAnimationChannel()\n\t\t\t\t\t.setSampler(samplers[channelDef.sampler])\n\t\t\t\t\t.setTargetNode(context.nodes[channelDef.target.node])\n\t\t\t\t\t.setTargetPath(channelDef.target.path);\n\n\t\t\t\tif (channelDef.extras) channel.setExtras(channelDef.extras);\n\n\t\t\t\tanimation.addChannel(channel);\n\t\t\t});\n\n\t\t\treturn animation;\n\t\t});\n\n\t\t/** Scenes. */\n\n\t\tconst sceneDefs = json.scenes || [];\n\n\t\tdoc.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.filter((extension) => extension.prereadTypes.includes(PropertyType.SCENE))\n\t\t\t.forEach((extension) => extension.preread(context, PropertyType.SCENE));\n\n\t\tcontext.scenes = sceneDefs.map((sceneDef) => {\n\t\t\tconst scene = doc.createScene(sceneDef.name);\n\n\t\t\tif (sceneDef.extras) scene.setExtras(sceneDef.extras);\n\n\t\t\tconst children = sceneDef.nodes || [];\n\n\t\t\tchildren.map((nodeIndex) => context.nodes[nodeIndex]).forEach((node) => scene.addChild(node));\n\n\t\t\treturn scene;\n\t\t});\n\n\t\tif (json.scene !== undefined) {\n\t\t\tdoc.getRoot().setDefaultScene(context.scenes[json.scene]);\n\t\t}\n\n\t\t/** Extensions (2/2). */\n\n\t\tdoc.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.forEach((extension) => extension.read(context));\n\n\t\treturn doc;\n\t}\n\n\tprivate static validate(jsonDoc: JSONDocument, options: Required<ReaderOptions>): void {\n\t\tconst json = jsonDoc.json;\n\n\t\tif (json.asset.version !== '2.0') {\n\t\t\tthrow new Error(`Unsupported glTF version, \"${json.asset.version}\".`);\n\t\t}\n\n\t\tif (json.extensionsRequired) {\n\t\t\tfor (const extensionName of json.extensionsRequired) {\n\t\t\t\tif (!options.extensions.find((extension) => extension.EXTENSION_NAME === extensionName)) {\n\t\t\t\t\tthrow new Error(`Missing required extension, \"${extensionName}\".`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (json.extensionsUsed) {\n\t\t\tfor (const extensionName of json.extensionsUsed) {\n\t\t\t\tif (!options.extensions.find((extension) => extension.EXTENSION_NAME === extensionName)) {\n\t\t\t\t\toptions.logger.warn(`Missing optional extension, \"${extensionName}\".`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Returns the contents of an interleaved accessor, as a typed array.\n * @internal\n */\nfunction getInterleavedArray(accessorDef: GLTF.IAccessor, context: ReaderContext): TypedArray {\n\tconst jsonDoc = context.jsonDoc;\n\tconst bufferView = context.bufferViews[accessorDef.bufferView!];\n\tconst bufferViewDef = jsonDoc.json.bufferViews![accessorDef.bufferView!];\n\n\tconst TypedArray = ComponentTypeToTypedArray[accessorDef.componentType];\n\tconst elementSize = Accessor.getElementSize(accessorDef.type);\n\tconst componentSize = TypedArray.BYTES_PER_ELEMENT;\n\tconst accessorByteOffset = accessorDef.byteOffset || 0;\n\n\tconst array = new TypedArray(accessorDef.count * elementSize);\n\tconst view = new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n\tconst byteStride = bufferViewDef.byteStride!;\n\n\tfor (let i = 0; i < accessorDef.count; i++) {\n\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\tconst byteOffset = accessorByteOffset + i * byteStride + j * componentSize;\n\t\t\tlet value: number;\n\t\t\tswitch (accessorDef.componentType) {\n\t\t\t\tcase Accessor.ComponentType.FLOAT:\n\t\t\t\t\tvalue = view.getFloat32(byteOffset, true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Accessor.ComponentType.UNSIGNED_INT:\n\t\t\t\t\tvalue = view.getUint32(byteOffset, true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Accessor.ComponentType.UNSIGNED_SHORT:\n\t\t\t\t\tvalue = view.getUint16(byteOffset, true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Accessor.ComponentType.UNSIGNED_BYTE:\n\t\t\t\t\tvalue = view.getUint8(byteOffset);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Accessor.ComponentType.SHORT:\n\t\t\t\t\tvalue = view.getInt16(byteOffset, true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Accessor.ComponentType.BYTE:\n\t\t\t\t\tvalue = view.getInt8(byteOffset);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Unexpected componentType \"${accessorDef.componentType}\".`);\n\t\t\t}\n\t\t\tarray[i * elementSize + j] = value;\n\t\t}\n\t}\n\n\treturn array;\n}\n\n/**\n * Returns the contents of an accessor, as a typed array.\n * @internal\n */\nfunction getAccessorArray(accessorDef: GLTF.IAccessor, context: ReaderContext): TypedArray {\n\tconst jsonDoc = context.jsonDoc;\n\tconst bufferView = context.bufferViews[accessorDef.bufferView!];\n\tconst bufferViewDef = jsonDoc.json.bufferViews![accessorDef.bufferView!];\n\n\tconst TypedArray = ComponentTypeToTypedArray[accessorDef.componentType];\n\tconst elementSize = Accessor.getElementSize(accessorDef.type);\n\tconst componentSize = TypedArray.BYTES_PER_ELEMENT;\n\tconst elementStride = elementSize * componentSize;\n\n\t// Interleaved buffer view.\n\tif (bufferViewDef.byteStride !== undefined && bufferViewDef.byteStride !== elementStride) {\n\t\treturn getInterleavedArray(accessorDef, context);\n\t}\n\n\tconst byteOffset = bufferView.byteOffset + (accessorDef.byteOffset || 0);\n\tconst byteLength = accessorDef.count * elementSize * componentSize;\n\n\t// Might optimize this to avoid deep copy later, but it's useful for now and not a known\n\t// bottleneck. See https://github.com/donmccurdy/glTF-Transform/issues/256.\n\treturn new TypedArray(bufferView.buffer.slice(byteOffset, byteOffset + byteLength));\n}\n\n/**\n * Returns the contents of a sparse accessor, as a typed array.\n * @internal\n */\nfunction getSparseArray(accessorDef: GLTF.IAccessor, context: ReaderContext): TypedArray {\n\tconst TypedArray = ComponentTypeToTypedArray[accessorDef.componentType];\n\tconst elementSize = Accessor.getElementSize(accessorDef.type);\n\n\tlet array: TypedArray;\n\tif (accessorDef.bufferView !== undefined) {\n\t\tarray = getAccessorArray(accessorDef, context);\n\t} else {\n\t\tarray = new TypedArray(accessorDef.count * elementSize);\n\t}\n\n\tconst sparseDef = accessorDef.sparse!;\n\tconst count = sparseDef.count;\n\tconst indicesDef = { ...accessorDef, ...sparseDef.indices, count, type: 'SCALAR' };\n\tconst valuesDef = { ...accessorDef, ...sparseDef.values, count };\n\tconst indices = getAccessorArray(indicesDef as GLTF.IAccessor, context);\n\tconst values = getAccessorArray(valuesDef, context);\n\n\t// Override indices given in the sparse data.\n\tfor (let i = 0; i < indicesDef.count; i++) {\n\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\tarray[indices[i] * elementSize + j] = values[i * elementSize + j];\n\t\t}\n\t}\n\n\treturn array;\n}\n","import { BufferViewUsage, Format, PropertyType } from '../constants';\nimport { Document } from '../document';\nimport { JSONDocument } from '../json-document';\nimport {\n\tAccessor,\n\tAnimation,\n\tBuffer,\n\tCamera,\n\tMaterial,\n\tMesh,\n\tNode,\n\tProperty,\n\tScene,\n\tSkin,\n\tTexture,\n\tTextureInfo,\n} from '../properties';\nimport { GLTF } from '../types/gltf';\nimport { ImageUtils, Logger } from '../utils';\nimport { WriterOptions } from './writer';\n\ntype PropertyDef = GLTF.IScene | GLTF.INode | GLTF.IMaterial | GLTF.ISkin | GLTF.ITexture;\n\nenum BufferViewTarget {\n\tARRAY_BUFFER = 34962,\n\tELEMENT_ARRAY_BUFFER = 34963,\n}\n\n/**\n * Model class providing writing state to a {@link Writer} and its {@link Extension}\n * implementations.\n *\n * @hidden\n */\nexport class WriterContext {\n\t/** Explicit buffer view targets defined by glTF specification. */\n\tpublic static readonly BufferViewTarget = BufferViewTarget;\n\t/**\n\t * Implicit buffer view usage, not required by glTF specification, but nonetheless useful for\n\t * proper grouping of accessors into buffer views. Additional usages are defined by extensions,\n\t * like `EXT_mesh_gpu_instancing`.\n\t */\n\tpublic static readonly BufferViewUsage = BufferViewUsage;\n\t/** Maps usage type to buffer view target. Usages not mapped have undefined targets. */\n\tpublic static readonly USAGE_TO_TARGET: { [key: string]: BufferViewTarget | undefined } = {\n\t\t[BufferViewUsage.ARRAY_BUFFER]: BufferViewTarget.ARRAY_BUFFER,\n\t\t[BufferViewUsage.ELEMENT_ARRAY_BUFFER]: BufferViewTarget.ELEMENT_ARRAY_BUFFER,\n\t};\n\n\tpublic readonly accessorIndexMap = new Map<Accessor, number>();\n\tpublic readonly animationIndexMap = new Map<Animation, number>();\n\tpublic readonly bufferIndexMap = new Map<Buffer, number>();\n\tpublic readonly cameraIndexMap = new Map<Camera, number>();\n\tpublic readonly skinIndexMap = new Map<Skin, number>();\n\tpublic readonly materialIndexMap = new Map<Material, number>();\n\tpublic readonly meshIndexMap = new Map<Mesh, number>();\n\tpublic readonly nodeIndexMap = new Map<Node, number>();\n\tpublic readonly imageIndexMap = new Map<Texture, number>();\n\tpublic readonly textureDefIndexMap = new Map<string, number>(); // textureDef JSON -> index\n\tpublic readonly textureInfoDefMap = new Map<TextureInfo, GLTF.ITextureInfo>();\n\tpublic readonly samplerDefIndexMap = new Map<string, number>(); // samplerDef JSON -> index\n\tpublic readonly sceneIndexMap = new Map<Scene, number>();\n\n\tpublic readonly imageBufferViews: Uint8Array[] = [];\n\tpublic readonly otherBufferViews = new Map<Buffer, Uint8Array[]>();\n\tpublic readonly otherBufferViewsIndexMap = new Map<Uint8Array, number>();\n\tpublic readonly extensionData: { [key: string]: unknown } = {};\n\n\tpublic bufferURIGenerator: UniqueURIGenerator;\n\tpublic imageURIGenerator: UniqueURIGenerator;\n\tpublic logger: Logger;\n\n\tprivate readonly _accessorUsageMap = new Map<Accessor, BufferViewUsage | string>();\n\tpublic readonly accessorUsageGroupedByParent = new Set<string>(['ARRAY_BUFFER']);\n\tpublic readonly accessorParents = new Map<Property, Set<Accessor>>();\n\n\tconstructor(\n\t\tprivate readonly _doc: Document,\n\t\tpublic readonly jsonDoc: JSONDocument,\n\t\tpublic readonly options: Required<WriterOptions>\n\t) {\n\t\tconst root = _doc.getRoot();\n\t\tconst numBuffers = root.listBuffers().length;\n\t\tconst numImages = root.listTextures().length;\n\t\tthis.bufferURIGenerator = new UniqueURIGenerator(numBuffers > 1, options.basename);\n\t\tthis.imageURIGenerator = new UniqueURIGenerator(numImages > 1, options.basename);\n\t\tthis.logger = _doc.getLogger();\n\t}\n\n\t/**\n\t * Creates a TextureInfo definition, and any Texture or Sampler definitions it requires. If\n\t * possible, Texture and Sampler definitions are shared.\n\t */\n\tpublic createTextureInfoDef(texture: Texture, textureInfo: TextureInfo): GLTF.ITextureInfo {\n\t\tconst samplerDef = {\n\t\t\tmagFilter: textureInfo.getMagFilter() || undefined,\n\t\t\tminFilter: textureInfo.getMinFilter() || undefined,\n\t\t\twrapS: textureInfo.getWrapS(),\n\t\t\twrapT: textureInfo.getWrapT(),\n\t\t} as GLTF.ISampler;\n\n\t\tconst samplerKey = JSON.stringify(samplerDef);\n\t\tif (!this.samplerDefIndexMap.has(samplerKey)) {\n\t\t\tthis.samplerDefIndexMap.set(samplerKey, this.jsonDoc.json.samplers!.length);\n\t\t\tthis.jsonDoc.json.samplers!.push(samplerDef);\n\t\t}\n\n\t\tconst textureDef = {\n\t\t\tsource: this.imageIndexMap.get(texture),\n\t\t\tsampler: this.samplerDefIndexMap.get(samplerKey),\n\t\t} as GLTF.ITexture;\n\n\t\tconst textureKey = JSON.stringify(textureDef);\n\t\tif (!this.textureDefIndexMap.has(textureKey)) {\n\t\t\tthis.textureDefIndexMap.set(textureKey, this.jsonDoc.json.textures!.length);\n\t\t\tthis.jsonDoc.json.textures!.push(textureDef);\n\t\t}\n\n\t\tconst textureInfoDef = {\n\t\t\tindex: this.textureDefIndexMap.get(textureKey),\n\t\t} as GLTF.ITextureInfo;\n\n\t\tif (textureInfo.getTexCoord() !== 0) {\n\t\t\ttextureInfoDef.texCoord = textureInfo.getTexCoord();\n\t\t}\n\n\t\tthis.textureInfoDefMap.set(textureInfo, textureInfoDef);\n\n\t\treturn textureInfoDef;\n\t}\n\n\tpublic createPropertyDef(property: Property): PropertyDef {\n\t\tconst def = {} as PropertyDef;\n\t\tif (property.getName()) {\n\t\t\tdef.name = property.getName();\n\t\t}\n\t\tif (Object.keys(property.getExtras()).length > 0) {\n\t\t\tdef.extras = property.getExtras();\n\t\t}\n\t\treturn def;\n\t}\n\n\tpublic createAccessorDef(accessor: Accessor): GLTF.IAccessor {\n\t\tconst accessorDef = this.createPropertyDef(accessor) as GLTF.IAccessor;\n\t\taccessorDef.type = accessor.getType();\n\t\taccessorDef.componentType = accessor.getComponentType();\n\t\taccessorDef.count = accessor.getCount();\n\n\t\tconst needsBounds = this._doc\n\t\t\t.getGraph()\n\t\t\t.listParentEdges(accessor)\n\t\t\t.some(\n\t\t\t\t(edge) =>\n\t\t\t\t\t(edge.getName() === 'attributes' && edge.getAttributes().key === 'POSITION') ||\n\t\t\t\t\tedge.getName() === 'input'\n\t\t\t);\n\t\tif (needsBounds) {\n\t\t\taccessorDef.max = accessor.getMax([]).map(Math.fround);\n\t\t\taccessorDef.min = accessor.getMin([]).map(Math.fround);\n\t\t}\n\n\t\tif (accessor.getNormalized()) {\n\t\t\taccessorDef.normalized = accessor.getNormalized();\n\t\t}\n\n\t\treturn accessorDef;\n\t}\n\n\tpublic createImageData(imageDef: GLTF.IImage, data: Uint8Array, texture: Texture): void {\n\t\tif (this.options.format === Format.GLB) {\n\t\t\tthis.imageBufferViews.push(data);\n\t\t\timageDef.bufferView = this.jsonDoc.json.bufferViews!.length;\n\t\t\tthis.jsonDoc.json.bufferViews!.push({\n\t\t\t\tbuffer: 0,\n\t\t\t\tbyteOffset: -1, // determined while iterating buffers, in Writer.ts.\n\t\t\t\tbyteLength: data.byteLength,\n\t\t\t});\n\t\t} else {\n\t\t\tconst extension = ImageUtils.mimeTypeToExtension(texture.getMimeType());\n\t\t\timageDef.uri = this.imageURIGenerator.createURI(texture, extension);\n\t\t\tthis.jsonDoc.resources[imageDef.uri] = data;\n\t\t}\n\t}\n\n\t/**\n\t * Returns implicit usage type of the given accessor, related to grouping accessors into\n\t * buffer views. Usage is a superset of buffer view target, including ARRAY_BUFFER and\n\t * ELEMENT_ARRAY_BUFFER, but also usages that do not match GPU buffer view targets such as\n\t * IBMs. Additional usages are defined by extensions, like `EXT_mesh_gpu_instancing`.\n\t */\n\tpublic getAccessorUsage(accessor: Accessor): BufferViewUsage | string {\n\t\tconst cachedUsage = this._accessorUsageMap.get(accessor);\n\t\tif (cachedUsage) return cachedUsage;\n\n\t\tfor (const edge of this._doc.getGraph().listParentEdges(accessor)) {\n\t\t\tconst { usage } = edge.getAttributes() as { usage: BufferViewUsage | undefined };\n\n\t\t\tif (usage) return usage;\n\n\t\t\tif (edge.getParent().propertyType !== PropertyType.ROOT) {\n\t\t\t\tthis._doc.getLogger().warn(`Missing attribute \".usage\" on edge, \"${edge.getName()}\".`);\n\t\t\t}\n\t\t}\n\n\t\t// Group accessors with no specified usage into a miscellaneous buffer view.\n\t\treturn WriterContext.BufferViewUsage.OTHER;\n\t}\n\n\t/**\n\t * Sets usage for the given accessor. Some accessor types must be grouped into\n\t * buffer views with like accessors. This includes the specified buffer view \"targets\", but\n\t * also implicit usage like IBMs or instanced mesh attributes. If unspecified, an accessor\n\t * will be grouped with other accessors of unspecified usage.\n\t */\n\tpublic addAccessorToUsageGroup(accessor: Accessor, usage: BufferViewUsage | string): this {\n\t\tconst prevUsage = this._accessorUsageMap.get(accessor);\n\t\tif (prevUsage && prevUsage !== usage) {\n\t\t\tthrow new Error(`Accessor with usage \"${prevUsage}\" cannot be reused as \"${usage}\".`);\n\t\t}\n\t\tthis._accessorUsageMap.set(accessor, usage);\n\t\treturn this;\n\t}\n\n\t/** Lists accessors grouped by usage. Accessors with unspecified usage are not included. */\n\tpublic listAccessorUsageGroups(): { [key: string]: Accessor[] } {\n\t\tconst result = {} as { [key: string]: Accessor[] };\n\t\tfor (const [accessor, usage] of Array.from(this._accessorUsageMap.entries())) {\n\t\t\tresult[usage] = result[usage] || [];\n\t\t\tresult[usage].push(accessor);\n\t\t}\n\t\treturn result;\n\t}\n}\n\nexport class UniqueURIGenerator {\n\tprivate counter = 1;\n\n\tconstructor(private readonly multiple: boolean, private readonly basename: string) {}\n\n\tpublic createURI(object: Texture | Buffer, extension: string): string {\n\t\tif (object.getURI()) {\n\t\t\treturn object.getURI();\n\t\t} else if (!this.multiple) {\n\t\t\treturn `${this.basename}.${extension}`;\n\t\t} else {\n\t\t\treturn `${this.basename}_${this.counter++}.${extension}`;\n\t\t}\n\t}\n}\n","import { Format, GLB_BUFFER, PropertyType, VERSION, VertexLayout } from '../constants';\nimport { Document } from '../document';\nimport { Extension } from '../extension';\nimport { GraphEdge } from 'property-graph';\nimport { JSONDocument } from '../json-document';\nimport { Accessor, AnimationSampler, Camera, Material, Property } from '../properties';\nimport { GLTF } from '../types/gltf';\nimport { BufferUtils, Logger, MathUtils } from '../utils';\nimport { WriterContext } from './writer-context';\n\nconst { BufferViewUsage } = WriterContext;\n\nexport interface WriterOptions {\n\tformat: Format;\n\tlogger?: Logger;\n\tbasename?: string;\n\tvertexLayout?: VertexLayout;\n\tdependencies?: { [key: string]: unknown };\n\textensions?: typeof Extension[];\n}\n\n/** @internal */\nexport class GLTFWriter {\n\tpublic static write(doc: Document, options: Required<WriterOptions>): JSONDocument {\n\t\tconst root = doc.getRoot();\n\t\tconst json = {\n\t\t\tasset: { generator: `glTF-Transform ${VERSION}`, ...root.getAsset() },\n\t\t\textras: { ...root.getExtras() },\n\t\t} as GLTF.IGLTF;\n\t\tconst jsonDoc = { json, resources: {} } as JSONDocument;\n\n\t\tconst context = new WriterContext(doc, jsonDoc, options);\n\t\tconst logger = options.logger || Logger.DEFAULT_INSTANCE;\n\n\t\t/* Extensions (1/2). */\n\n\t\t// Extensions present on the Document are not written unless they are also registered with\n\t\t// the I/O class. This ensures that setup in `extension.register()` is completed, and\n\t\t// allows a Document to be written with specific extensions disabled.\n\t\tconst extensionsRegistered = new Set(options.extensions.map((ext) => ext.EXTENSION_NAME));\n\t\tconst extensionsUsed = doc\n\t\t\t.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.filter((ext) => extensionsRegistered.has(ext.extensionName));\n\t\tconst extensionsRequired = doc\n\t\t\t.getRoot()\n\t\t\t.listExtensionsRequired()\n\t\t\t.filter((ext) => extensionsRegistered.has(ext.extensionName));\n\n\t\tif (extensionsUsed.length < doc.getRoot().listExtensionsUsed().length) {\n\t\t\tlogger.debug('Some extensions were not registered for I/O, and will not be written.');\n\t\t}\n\n\t\tfor (const extension of extensionsUsed) {\n\t\t\tfor (const key of extension.writeDependencies) {\n\t\t\t\textension.install(key, options.dependencies[key]);\n\t\t\t}\n\t\t}\n\n\t\t/* Utilities. */\n\n\t\tinterface BufferViewResult {\n\t\t\tbyteLength: number;\n\t\t\tbuffers: Uint8Array[];\n\t\t}\n\n\t\t/**\n\t\t * Pack a group of accessors into a sequential buffer view. Appends accessor and buffer view\n\t\t * definitions to the root JSON lists.\n\t\t *\n\t\t * @param accessors Accessors to be included.\n\t\t * @param bufferIndex Buffer to write to.\n\t\t * @param bufferByteOffset Current offset into the buffer, accounting for other buffer views.\n\t\t * @param bufferViewTarget (Optional) target use of the buffer view.\n\t\t */\n\t\tfunction concatAccessors(\n\t\t\taccessors: Accessor[],\n\t\t\tbufferIndex: number,\n\t\t\tbufferByteOffset: number,\n\t\t\tbufferViewTarget?: number\n\t\t): BufferViewResult {\n\t\t\tconst buffers: Uint8Array[] = [];\n\t\t\tlet byteLength = 0;\n\n\t\t\t// Create accessor definitions, determining size of final buffer view.\n\t\t\tfor (const accessor of accessors) {\n\t\t\t\tconst accessorDef = context.createAccessorDef(accessor);\n\t\t\t\taccessorDef.bufferView = json.bufferViews!.length;\n\n\t\t\t\tconst accessorArray = accessor.getArray()!;\n\t\t\t\tconst data = BufferUtils.pad(BufferUtils.toView(accessorArray));\n\t\t\t\taccessorDef.byteOffset = byteLength;\n\t\t\t\tbyteLength += data.byteLength;\n\t\t\t\tbuffers.push(data);\n\n\t\t\t\tcontext.accessorIndexMap.set(accessor, json.accessors!.length);\n\t\t\t\tjson.accessors!.push(accessorDef);\n\t\t\t}\n\n\t\t\t// Create buffer view definition.\n\t\t\tconst bufferViewData = BufferUtils.concat(buffers);\n\t\t\tconst bufferViewDef: GLTF.IBufferView = {\n\t\t\t\tbuffer: bufferIndex,\n\t\t\t\tbyteOffset: bufferByteOffset,\n\t\t\t\tbyteLength: bufferViewData.byteLength,\n\t\t\t};\n\t\t\tif (bufferViewTarget) bufferViewDef.target = bufferViewTarget;\n\t\t\tjson.bufferViews!.push(bufferViewDef);\n\n\t\t\treturn { buffers, byteLength };\n\t\t}\n\n\t\t/**\n\t\t * Pack a group of accessors into an interleaved buffer view. Appends accessor and buffer\n\t\t * view definitions to the root JSON lists. Buffer view target is implicitly attribute data.\n\t\t *\n\t\t * References:\n\t\t * - [Apple • Best Practices for Working with Vertex Data](https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html)\n\t\t * - [Khronos • Vertex Specification Best Practices](https://www.khronos.org/opengl/wiki/Vertex_Specification_Best_Practices)\n\t\t *\n\t\t * @param accessors Accessors to be included.\n\t\t * @param bufferIndex Buffer to write to.\n\t\t * @param bufferByteOffset Offset into the buffer, accounting for other buffer views.\n\t\t */\n\t\tfunction interleaveAccessors(\n\t\t\taccessors: Accessor[],\n\t\t\tbufferIndex: number,\n\t\t\tbufferByteOffset: number\n\t\t): BufferViewResult {\n\t\t\tconst vertexCount = accessors[0].getCount();\n\t\t\tlet byteStride = 0;\n\n\t\t\t// Create accessor definitions, determining size and stride of final buffer view.\n\t\t\tfor (const accessor of accessors) {\n\t\t\t\tconst accessorDef = context.createAccessorDef(accessor);\n\t\t\t\taccessorDef.bufferView = json.bufferViews!.length;\n\t\t\t\taccessorDef.byteOffset = byteStride;\n\n\t\t\t\tconst elementSize = accessor.getElementSize();\n\t\t\t\tconst componentSize = accessor.getComponentSize();\n\t\t\t\tbyteStride += BufferUtils.padNumber(elementSize * componentSize);\n\n\t\t\t\tcontext.accessorIndexMap.set(accessor, json.accessors!.length);\n\t\t\t\tjson.accessors!.push(accessorDef);\n\t\t\t}\n\n\t\t\t// Allocate interleaved buffer view.\n\t\t\tconst byteLength = vertexCount * byteStride;\n\t\t\tconst buffer = new ArrayBuffer(byteLength);\n\t\t\tconst view = new DataView(buffer);\n\n\t\t\t// Write interleaved accessor data to the buffer view.\n\t\t\tfor (let i = 0; i < vertexCount; i++) {\n\t\t\t\tlet vertexByteOffset = 0;\n\t\t\t\tfor (const accessor of accessors) {\n\t\t\t\t\tconst elementSize = accessor.getElementSize();\n\t\t\t\t\tconst componentSize = accessor.getComponentSize();\n\t\t\t\t\tconst componentType = accessor.getComponentType();\n\t\t\t\t\tconst array = accessor.getArray()!;\n\t\t\t\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\t\t\t\tconst viewByteOffset = i * byteStride + vertexByteOffset + j * componentSize;\n\t\t\t\t\t\tconst value = array[i * elementSize + j];\n\t\t\t\t\t\tswitch (componentType) {\n\t\t\t\t\t\t\tcase Accessor.ComponentType.FLOAT:\n\t\t\t\t\t\t\t\tview.setFloat32(viewByteOffset, value, true);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Accessor.ComponentType.BYTE:\n\t\t\t\t\t\t\t\tview.setInt8(viewByteOffset, value);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Accessor.ComponentType.SHORT:\n\t\t\t\t\t\t\t\tview.setInt16(viewByteOffset, value, true);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Accessor.ComponentType.UNSIGNED_BYTE:\n\t\t\t\t\t\t\t\tview.setUint8(viewByteOffset, value);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Accessor.ComponentType.UNSIGNED_SHORT:\n\t\t\t\t\t\t\t\tview.setUint16(viewByteOffset, value, true);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Accessor.ComponentType.UNSIGNED_INT:\n\t\t\t\t\t\t\t\tview.setUint32(viewByteOffset, value, true);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tthrow new Error('Unexpected component type: ' + componentType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvertexByteOffset += BufferUtils.padNumber(elementSize * componentSize);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Create buffer view definition.\n\t\t\tconst bufferViewDef: GLTF.IBufferView = {\n\t\t\t\tbuffer: bufferIndex,\n\t\t\t\tbyteOffset: bufferByteOffset,\n\t\t\t\tbyteLength: byteLength,\n\t\t\t\tbyteStride: byteStride,\n\t\t\t\ttarget: WriterContext.BufferViewTarget.ARRAY_BUFFER,\n\t\t\t};\n\t\t\tjson.bufferViews!.push(bufferViewDef);\n\n\t\t\treturn { byteLength, buffers: [new Uint8Array(buffer)] };\n\t\t}\n\n\t\t/* Data use pre-processing. */\n\n\t\tconst accessorRefs = new Map<Accessor, GraphEdge<Property, Accessor>[]>();\n\n\t\t// Gather all accessors, creating a map to look up their uses.\n\t\tfor (const ref of doc.getGraph().listEdges()) {\n\t\t\tif (ref.getParent() === root) continue;\n\n\t\t\tconst child = ref.getChild();\n\n\t\t\tif (child instanceof Accessor) {\n\t\t\t\tconst uses = accessorRefs.get(child) || [];\n\t\t\t\tuses.push(ref as GraphEdge<Property, Accessor>);\n\t\t\t\taccessorRefs.set(child, uses);\n\t\t\t}\n\t\t}\n\n\t\tjson.accessors = [];\n\t\tjson.bufferViews = [];\n\n\t\t/* Textures. */\n\n\t\t// glTF-Transform's \"Texture\" properties correspond 1:1 with glTF \"Image\" properties, and\n\t\t// with image files. The glTF file may contain more one texture per image, where images\n\t\t// are reused with different sampler properties.\n\t\tjson.samplers = [];\n\t\tjson.textures = [];\n\t\tjson.images = root.listTextures().map((texture, textureIndex) => {\n\t\t\tconst imageDef = context.createPropertyDef(texture) as GLTF.IImage;\n\n\t\t\tif (texture.getMimeType()) {\n\t\t\t\timageDef.mimeType = texture.getMimeType();\n\t\t\t}\n\n\t\t\tconst image = texture.getImage();\n\t\t\tif (image) {\n\t\t\t\tcontext.createImageData(imageDef, image, texture);\n\t\t\t}\n\n\t\t\tcontext.imageIndexMap.set(texture, textureIndex);\n\t\t\treturn imageDef;\n\t\t});\n\n\t\t/* Accessors. */\n\n\t\textensionsUsed\n\t\t\t.filter((extension) => extension.prewriteTypes.includes(PropertyType.ACCESSOR))\n\t\t\t.forEach((extension) => extension.prewrite(context, PropertyType.ACCESSOR));\n\t\troot.listAccessors().forEach((accessor) => {\n\t\t\t// Attributes are grouped and interleaved in one buffer view per mesh primitive.\n\t\t\t// Indices for all primitives are grouped into a single buffer view. IBMs are grouped\n\t\t\t// into a single buffer view. Other usage (if specified by extensions) also goes into\n\t\t\t// a dedicated buffer view. Everything else goes into a miscellaneous buffer view.\n\n\t\t\t// Certain accessor usage should group data into buffer views by the accessor parent.\n\t\t\t// The `accessorParents` map uses the first parent of each accessor for this purpose.\n\t\t\tconst groupByParent = context.accessorUsageGroupedByParent;\n\t\t\tconst accessorParents = context.accessorParents;\n\n\t\t\t// Skip if already written by an extension.\n\t\t\tif (context.accessorIndexMap.has(accessor)) return;\n\n\t\t\t// Assign usage for core accessor usage types (explicit targets and implicit usage).\n\t\t\tconst accessorEdges = accessorRefs.get(accessor) || [];\n\t\t\tconst usage = context.getAccessorUsage(accessor);\n\t\t\tcontext.addAccessorToUsageGroup(accessor, usage);\n\n\t\t\t// For accessor usage that requires grouping by parent (vertex and instance\n\t\t\t// attributes) organize buffer views accordingly.\n\t\t\tif (groupByParent.has(usage)) {\n\t\t\t\tconst parent = accessorEdges[0].getParent();\n\t\t\t\tconst parentAccessors = accessorParents.get(parent) || new Set<Accessor>();\n\t\t\t\tparentAccessors.add(accessor);\n\t\t\t\taccessorParents.set(parent, parentAccessors);\n\t\t\t}\n\t\t});\n\n\t\t/* Buffers, buffer views. */\n\n\t\textensionsUsed\n\t\t\t.filter((extension) => extension.prewriteTypes.includes(PropertyType.BUFFER))\n\t\t\t.forEach((extension) => extension.prewrite(context, PropertyType.BUFFER));\n\n\t\tconst hasBinaryResources =\n\t\t\troot.listAccessors().length > 0 || root.listTextures().length > 0 || context.otherBufferViews.size > 0;\n\t\tif (hasBinaryResources && root.listBuffers().length === 0) {\n\t\t\tthrow new Error('Buffer required for Document resources, but none was found.');\n\t\t}\n\n\t\tjson.buffers = [];\n\t\troot.listBuffers().forEach((buffer, index) => {\n\t\t\tconst bufferDef = context.createPropertyDef(buffer) as GLTF.IBuffer;\n\t\t\tconst groupByParent = context.accessorUsageGroupedByParent;\n\t\t\tconst accessorParents = context.accessorParents;\n\n\t\t\tconst bufferAccessors = buffer\n\t\t\t\t.listParents()\n\t\t\t\t.filter((property) => property instanceof Accessor) as Accessor[];\n\t\t\tconst bufferAccessorsSet = new Set(bufferAccessors);\n\n\t\t\t// Write accessor groups to buffer views.\n\n\t\t\tconst buffers: Uint8Array[] = [];\n\t\t\tconst bufferIndex = json.buffers!.length;\n\t\t\tlet bufferByteLength = 0;\n\n\t\t\tconst usageGroups = context.listAccessorUsageGroups();\n\n\t\t\tfor (const usage in usageGroups) {\n\t\t\t\tif (groupByParent.has(usage)) {\n\t\t\t\t\t// Accessors grouped by (first) parent, including vertex and instance\n\t\t\t\t\t// attributes.\n\t\t\t\t\tfor (const parentAccessors of Array.from(accessorParents.values())) {\n\t\t\t\t\t\tconst accessors = Array.from(parentAccessors)\n\t\t\t\t\t\t\t.filter((a) => bufferAccessorsSet.has(a))\n\t\t\t\t\t\t\t.filter((a) => context.getAccessorUsage(a) === usage);\n\t\t\t\t\t\tif (!accessors.length) continue;\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tusage !== BufferViewUsage.ARRAY_BUFFER ||\n\t\t\t\t\t\t\toptions.vertexLayout === VertexLayout.INTERLEAVED\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// Case 1: Non-vertex data OR interleaved vertex data.\n\n\t\t\t\t\t\t\t// Instanced data is not interleaved, see:\n\t\t\t\t\t\t\t// https://github.com/KhronosGroup/glTF/pull/1888\n\t\t\t\t\t\t\tconst result =\n\t\t\t\t\t\t\t\tusage === BufferViewUsage.ARRAY_BUFFER\n\t\t\t\t\t\t\t\t\t? interleaveAccessors(accessors, bufferIndex, bufferByteLength)\n\t\t\t\t\t\t\t\t\t: concatAccessors(accessors, bufferIndex, bufferByteLength);\n\t\t\t\t\t\t\tbufferByteLength += result.byteLength;\n\t\t\t\t\t\t\tbuffers.push(...result.buffers);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Case 2: Non-interleaved vertex data.\n\n\t\t\t\t\t\t\tfor (const accessor of accessors) {\n\t\t\t\t\t\t\t\t// We 'interleave' a single accessor because the method pads to\n\t\t\t\t\t\t\t\t// 4-byte boundaries, which concatAccessors() does not.\n\t\t\t\t\t\t\t\tconst result = interleaveAccessors([accessor], bufferIndex, bufferByteLength);\n\t\t\t\t\t\t\t\tbufferByteLength += result.byteLength;\n\t\t\t\t\t\t\t\tbuffers.push(...result.buffers);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Accessors concatenated end-to-end, including indices, IBMs, and other data.\n\t\t\t\t\tconst accessors = usageGroups[usage].filter((a) => bufferAccessorsSet.has(a));\n\t\t\t\t\tif (!accessors.length) continue;\n\n\t\t\t\t\tconst target =\n\t\t\t\t\t\tusage === BufferViewUsage.ELEMENT_ARRAY_BUFFER\n\t\t\t\t\t\t\t? WriterContext.BufferViewTarget.ELEMENT_ARRAY_BUFFER\n\t\t\t\t\t\t\t: undefined;\n\t\t\t\t\tconst result = concatAccessors(accessors, bufferIndex, bufferByteLength, target);\n\t\t\t\t\tbufferByteLength += result.byteLength;\n\t\t\t\t\tbuffers.push(...result.buffers);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// We only support embedded images in GLB, where the embedded buffer must be the first.\n\t\t\t// Additional buffers are currently left empty (see EXT_meshopt_compression fallback).\n\t\t\tif (context.imageBufferViews.length && index === 0) {\n\t\t\t\tfor (let i = 0; i < context.imageBufferViews.length; i++) {\n\t\t\t\t\tjson.bufferViews![json.images![i].bufferView!].byteOffset = bufferByteLength;\n\t\t\t\t\tbufferByteLength += context.imageBufferViews[i].byteLength;\n\t\t\t\t\tbuffers.push(context.imageBufferViews[i]);\n\n\t\t\t\t\tif (bufferByteLength % 8) {\n\t\t\t\t\t\t// See: https://github.com/KhronosGroup/glTF/issues/1935\n\t\t\t\t\t\tconst imagePadding = 8 - (bufferByteLength % 8);\n\t\t\t\t\t\tbufferByteLength += imagePadding;\n\t\t\t\t\t\tbuffers.push(new Uint8Array(imagePadding));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (context.otherBufferViews.has(buffer)) {\n\t\t\t\tfor (const data of context.otherBufferViews.get(buffer)!) {\n\t\t\t\t\tjson.bufferViews!.push({\n\t\t\t\t\t\tbuffer: bufferIndex,\n\t\t\t\t\t\tbyteOffset: bufferByteLength,\n\t\t\t\t\t\tbyteLength: data.byteLength,\n\t\t\t\t\t});\n\t\t\t\t\tcontext.otherBufferViewsIndexMap.set(data, json.bufferViews!.length - 1);\n\t\t\t\t\tbufferByteLength += data.byteLength;\n\t\t\t\t\tbuffers.push(data);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (bufferByteLength) {\n\t\t\t\t// Assign buffer URI.\n\t\t\t\tlet uri: string;\n\t\t\t\tif (options.format === Format.GLB) {\n\t\t\t\t\turi = GLB_BUFFER;\n\t\t\t\t} else {\n\t\t\t\t\turi = context.bufferURIGenerator.createURI(buffer, 'bin');\n\t\t\t\t\tbufferDef.uri = uri;\n\t\t\t\t}\n\n\t\t\t\t// Write buffer views to buffer.\n\t\t\t\tbufferDef.byteLength = bufferByteLength;\n\t\t\t\tjsonDoc.resources[uri] = BufferUtils.concat(buffers);\n\t\t\t}\n\n\t\t\tjson.buffers!.push(bufferDef);\n\t\t\tcontext.bufferIndexMap.set(buffer, index);\n\t\t});\n\n\t\tif (root.listAccessors().find((a) => !a.getBuffer())) {\n\t\t\tlogger.warn('Skipped writing one or more Accessors: no Buffer assigned.');\n\t\t}\n\n\t\t/* Materials. */\n\n\t\tjson.materials = root.listMaterials().map((material, index) => {\n\t\t\tconst materialDef = context.createPropertyDef(material) as GLTF.IMaterial;\n\n\t\t\t// Program state & blending.\n\n\t\t\tif (material.getAlphaMode() !== Material.AlphaMode.OPAQUE) {\n\t\t\t\tmaterialDef.alphaMode = material.getAlphaMode();\n\t\t\t}\n\t\t\tif (material.getAlphaMode() === Material.AlphaMode.MASK) {\n\t\t\t\tmaterialDef.alphaCutoff = material.getAlphaCutoff();\n\t\t\t}\n\t\t\tif (material.getDoubleSided()) materialDef.doubleSided = true;\n\n\t\t\t// Factors.\n\n\t\t\tmaterialDef.pbrMetallicRoughness = {};\n\t\t\tif (!MathUtils.eq(material.getBaseColorFactor(), [1, 1, 1, 1])) {\n\t\t\t\tmaterialDef.pbrMetallicRoughness.baseColorFactor = material.getBaseColorFactor();\n\t\t\t}\n\t\t\tif (!MathUtils.eq(material.getEmissiveFactor(), [0, 0, 0])) {\n\t\t\t\tmaterialDef.emissiveFactor = material.getEmissiveFactor();\n\t\t\t}\n\t\t\tif (material.getRoughnessFactor() !== 1) {\n\t\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = material.getRoughnessFactor();\n\t\t\t}\n\t\t\tif (material.getMetallicFactor() !== 1) {\n\t\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = material.getMetallicFactor();\n\t\t\t}\n\n\t\t\t// Textures.\n\n\t\t\tif (material.getBaseColorTexture()) {\n\t\t\t\tconst texture = material.getBaseColorTexture()!;\n\t\t\t\tconst textureInfo = material.getBaseColorTextureInfo()!;\n\t\t\t\tmaterialDef.pbrMetallicRoughness.baseColorTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t}\n\n\t\t\tif (material.getEmissiveTexture()) {\n\t\t\t\tconst texture = material.getEmissiveTexture()!;\n\t\t\t\tconst textureInfo = material.getEmissiveTextureInfo()!;\n\t\t\t\tmaterialDef.emissiveTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t}\n\n\t\t\tif (material.getNormalTexture()) {\n\t\t\t\tconst texture = material.getNormalTexture()!;\n\t\t\t\tconst textureInfo = material.getNormalTextureInfo()!;\n\t\t\t\tconst textureInfoDef = context.createTextureInfoDef(\n\t\t\t\t\ttexture,\n\t\t\t\t\ttextureInfo\n\t\t\t\t) as GLTF.IMaterialNormalTextureInfo;\n\t\t\t\tif (material.getNormalScale() !== 1) {\n\t\t\t\t\ttextureInfoDef.scale = material.getNormalScale();\n\t\t\t\t}\n\t\t\t\tmaterialDef.normalTexture = textureInfoDef;\n\t\t\t}\n\n\t\t\tif (material.getOcclusionTexture()) {\n\t\t\t\tconst texture = material.getOcclusionTexture()!;\n\t\t\t\tconst textureInfo = material.getOcclusionTextureInfo()!;\n\t\t\t\tconst textureInfoDef = context.createTextureInfoDef(\n\t\t\t\t\ttexture,\n\t\t\t\t\ttextureInfo\n\t\t\t\t) as GLTF.IMaterialOcclusionTextureInfo;\n\t\t\t\tif (material.getOcclusionStrength() !== 1) {\n\t\t\t\t\ttextureInfoDef.strength = material.getOcclusionStrength();\n\t\t\t\t}\n\t\t\t\tmaterialDef.occlusionTexture = textureInfoDef;\n\t\t\t}\n\n\t\t\tif (material.getMetallicRoughnessTexture()) {\n\t\t\t\tconst texture = material.getMetallicRoughnessTexture()!;\n\t\t\t\tconst textureInfo = material.getMetallicRoughnessTextureInfo()!;\n\t\t\t\tmaterialDef.pbrMetallicRoughness.metallicRoughnessTexture = context.createTextureInfoDef(\n\t\t\t\t\ttexture,\n\t\t\t\t\ttextureInfo\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tcontext.materialIndexMap.set(material, index);\n\t\t\treturn materialDef;\n\t\t});\n\n\t\t/* Meshes. */\n\n\t\tjson.meshes = root.listMeshes().map((mesh, index) => {\n\t\t\tconst meshDef = context.createPropertyDef(mesh) as GLTF.IMesh;\n\n\t\t\tlet targetNames: string[] | null = null;\n\n\t\t\tmeshDef.primitives = mesh.listPrimitives().map((primitive) => {\n\t\t\t\tconst primitiveDef: GLTF.IMeshPrimitive = { attributes: {} };\n\n\t\t\t\tprimitiveDef.mode = primitive.getMode();\n\n\t\t\t\tconst material = primitive.getMaterial();\n\t\t\t\tif (material) {\n\t\t\t\t\tprimitiveDef.material = context.materialIndexMap.get(material);\n\t\t\t\t}\n\n\t\t\t\tif (Object.keys(primitive.getExtras()).length) {\n\t\t\t\t\tprimitiveDef.extras = primitive.getExtras();\n\t\t\t\t}\n\n\t\t\t\tconst indices = primitive.getIndices();\n\t\t\t\tif (indices) {\n\t\t\t\t\tprimitiveDef.indices = context.accessorIndexMap.get(indices);\n\t\t\t\t}\n\n\t\t\t\tfor (const semantic of primitive.listSemantics()) {\n\t\t\t\t\tprimitiveDef.attributes[semantic] = context.accessorIndexMap.get(\n\t\t\t\t\t\tprimitive.getAttribute(semantic)!\n\t\t\t\t\t)!;\n\t\t\t\t}\n\n\t\t\t\tfor (const target of primitive.listTargets()) {\n\t\t\t\t\tconst targetDef = {} as { [name: string]: number };\n\n\t\t\t\t\tfor (const semantic of target.listSemantics()) {\n\t\t\t\t\t\ttargetDef[semantic] = context.accessorIndexMap.get(target.getAttribute(semantic)!)!;\n\t\t\t\t\t}\n\n\t\t\t\t\tprimitiveDef.targets = primitiveDef.targets || [];\n\t\t\t\t\tprimitiveDef.targets.push(targetDef);\n\t\t\t\t}\n\n\t\t\t\tif (primitive.listTargets().length && !targetNames) {\n\t\t\t\t\ttargetNames = primitive.listTargets().map((target) => target.getName());\n\t\t\t\t}\n\n\t\t\t\treturn primitiveDef;\n\t\t\t});\n\n\t\t\tif (mesh.getWeights().length) {\n\t\t\t\tmeshDef.weights = mesh.getWeights();\n\t\t\t}\n\n\t\t\tif (targetNames) {\n\t\t\t\tmeshDef.extras = meshDef.extras || {};\n\t\t\t\tmeshDef.extras['targetNames'] = targetNames;\n\t\t\t}\n\n\t\t\tcontext.meshIndexMap.set(mesh, index);\n\t\t\treturn meshDef;\n\t\t});\n\n\t\t/** Cameras. */\n\n\t\tjson.cameras = root.listCameras().map((camera, index) => {\n\t\t\tconst cameraDef = context.createPropertyDef(camera) as GLTF.ICamera;\n\t\t\tcameraDef.type = camera.getType();\n\t\t\tif (cameraDef.type === Camera.Type.PERSPECTIVE) {\n\t\t\t\tcameraDef.perspective = {\n\t\t\t\t\tznear: camera.getZNear(),\n\t\t\t\t\tzfar: camera.getZFar(),\n\t\t\t\t\tyfov: camera.getYFov(),\n\t\t\t\t};\n\t\t\t\tconst aspectRatio = camera.getAspectRatio();\n\t\t\t\tif (aspectRatio !== null) {\n\t\t\t\t\tcameraDef.perspective.aspectRatio = aspectRatio;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcameraDef.orthographic = {\n\t\t\t\t\tznear: camera.getZNear(),\n\t\t\t\t\tzfar: camera.getZFar(),\n\t\t\t\t\txmag: camera.getXMag(),\n\t\t\t\t\tymag: camera.getYMag(),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tcontext.cameraIndexMap.set(camera, index);\n\t\t\treturn cameraDef;\n\t\t});\n\n\t\t/* Nodes. */\n\n\t\tjson.nodes = root.listNodes().map((node, index) => {\n\t\t\tconst nodeDef = context.createPropertyDef(node) as GLTF.INode;\n\n\t\t\tif (!MathUtils.eq(node.getTranslation(), [0, 0, 0])) {\n\t\t\t\tnodeDef.translation = node.getTranslation();\n\t\t\t}\n\n\t\t\tif (!MathUtils.eq(node.getRotation(), [0, 0, 0, 1])) {\n\t\t\t\tnodeDef.rotation = node.getRotation();\n\t\t\t}\n\n\t\t\tif (!MathUtils.eq(node.getScale(), [1, 1, 1])) {\n\t\t\t\tnodeDef.scale = node.getScale();\n\t\t\t}\n\n\t\t\tif (node.getWeights().length) {\n\t\t\t\tnodeDef.weights = node.getWeights();\n\t\t\t}\n\n\t\t\t// Attachments (mesh, camera, skin) defined later in writing process.\n\n\t\t\tcontext.nodeIndexMap.set(node, index);\n\t\t\treturn nodeDef;\n\t\t});\n\n\t\t/** Skins. */\n\n\t\tjson.skins = root.listSkins().map((skin, index) => {\n\t\t\tconst skinDef = context.createPropertyDef(skin) as GLTF.ISkin;\n\n\t\t\tconst inverseBindMatrices = skin.getInverseBindMatrices();\n\t\t\tif (inverseBindMatrices) {\n\t\t\t\tskinDef.inverseBindMatrices = context.accessorIndexMap.get(inverseBindMatrices);\n\t\t\t}\n\n\t\t\tconst skeleton = skin.getSkeleton();\n\t\t\tif (skeleton) {\n\t\t\t\tskinDef.skeleton = context.nodeIndexMap.get(skeleton);\n\t\t\t}\n\n\t\t\tskinDef.joints = skin.listJoints().map((joint) => context.nodeIndexMap.get(joint)!);\n\n\t\t\tcontext.skinIndexMap.set(skin, index);\n\t\t\treturn skinDef;\n\t\t});\n\n\t\t/** Node attachments. */\n\n\t\troot.listNodes().forEach((node, index) => {\n\t\t\tconst nodeDef = json.nodes![index];\n\n\t\t\tconst mesh = node.getMesh();\n\t\t\tif (mesh) {\n\t\t\t\tnodeDef.mesh = context.meshIndexMap.get(mesh);\n\t\t\t}\n\n\t\t\tconst camera = node.getCamera();\n\t\t\tif (camera) {\n\t\t\t\tnodeDef.camera = context.cameraIndexMap.get(camera);\n\t\t\t}\n\n\t\t\tconst skin = node.getSkin();\n\t\t\tif (skin) {\n\t\t\t\tnodeDef.skin = context.skinIndexMap.get(skin);\n\t\t\t}\n\n\t\t\tif (node.listChildren().length > 0) {\n\t\t\t\tnodeDef.children = node.listChildren().map((node) => context.nodeIndexMap.get(node)!);\n\t\t\t}\n\t\t});\n\n\t\t/** Animations. */\n\n\t\tjson.animations = root.listAnimations().map((animation, index) => {\n\t\t\tconst animationDef = context.createPropertyDef(animation) as GLTF.IAnimation;\n\n\t\t\tconst samplerIndexMap: Map<AnimationSampler, number> = new Map();\n\n\t\t\tanimationDef.samplers = animation.listSamplers().map((sampler, samplerIndex) => {\n\t\t\t\tconst samplerDef = context.createPropertyDef(sampler) as GLTF.IAnimationSampler;\n\t\t\t\tsamplerDef.input = context.accessorIndexMap.get(sampler.getInput()!)!;\n\t\t\t\tsamplerDef.output = context.accessorIndexMap.get(sampler.getOutput()!)!;\n\t\t\t\tsamplerDef.interpolation = sampler.getInterpolation();\n\t\t\t\tsamplerIndexMap.set(sampler, samplerIndex);\n\t\t\t\treturn samplerDef;\n\t\t\t});\n\n\t\t\tanimationDef.channels = animation.listChannels().map((channel) => {\n\t\t\t\tconst channelDef = context.createPropertyDef(channel) as GLTF.IAnimationChannel;\n\t\t\t\tchannelDef.sampler = samplerIndexMap.get(channel.getSampler()!)!;\n\t\t\t\tchannelDef.target = {\n\t\t\t\t\tnode: context.nodeIndexMap.get(channel.getTargetNode()!)!,\n\t\t\t\t\tpath: channel.getTargetPath()!,\n\t\t\t\t};\n\t\t\t\treturn channelDef;\n\t\t\t});\n\n\t\t\tcontext.animationIndexMap.set(animation, index);\n\t\t\treturn animationDef;\n\t\t});\n\n\t\t/* Scenes. */\n\n\t\tjson.scenes = root.listScenes().map((scene, index) => {\n\t\t\tconst sceneDef = context.createPropertyDef(scene) as GLTF.IScene;\n\t\t\tsceneDef.nodes = scene.listChildren().map((node) => context.nodeIndexMap.get(node)!);\n\t\t\tcontext.sceneIndexMap.set(scene, index);\n\t\t\treturn sceneDef;\n\t\t});\n\n\t\tconst defaultScene = root.getDefaultScene();\n\t\tif (defaultScene) {\n\t\t\tjson.scene = root.listScenes().indexOf(defaultScene);\n\t\t}\n\n\t\t/* Extensions (2/2). */\n\n\t\tjson.extensionsUsed = extensionsUsed.map((ext) => ext.extensionName);\n\t\tjson.extensionsRequired = extensionsRequired.map((ext) => ext.extensionName);\n\t\textensionsUsed.forEach((extension) => extension.write(context));\n\n\t\t//\n\n\t\tclean(json as unknown as Record<string, unknown>);\n\n\t\treturn jsonDoc;\n\t}\n}\n\n/**\n * Removes empty and null values from an object.\n * @param object\n * @internal\n */\nfunction clean(object: Record<string, unknown>): void {\n\tconst unused: string[] = [];\n\n\tfor (const key in object) {\n\t\tconst value = object[key];\n\t\tif (Array.isArray(value) && value.length === 0) {\n\t\t\tunused.push(key);\n\t\t} else if (value === null || value === '') {\n\t\t\tunused.push(key);\n\t\t} else if (value && typeof value === 'object' && Object.keys(value).length === 0) {\n\t\t\tunused.push(key);\n\t\t}\n\t}\n\n\tfor (const key of unused) {\n\t\tdelete object[key];\n\t}\n}\n","import { Format, GLB_BUFFER, VertexLayout } from '../constants';\nimport { Document } from '../document';\nimport { Extension } from '../extension';\nimport { JSONDocument } from '../json-document';\nimport { GLTF } from '../types/gltf';\nimport { BufferUtils, FileUtils, Logger, uuid } from '../utils/';\nimport { GLTFReader } from './reader';\nimport { GLTFWriter, WriterOptions } from './writer';\n\nenum ChunkType {\n\tJSON = 0x4e4f534a,\n\tBIN = 0x004e4942,\n}\n\ntype PublicWriterOptions = Partial<Pick<WriterOptions, 'format' | 'basename'>>;\n\n/**\n * # PlatformIO\n *\n * *Abstract I/O service.*\n *\n * The most common use of the I/O service is to read/write a {@link Document} with a given path.\n * Methods are also available for converting in-memory representations of raw glTF files, both\n * binary (*Uint8Array*) and JSON ({@link JSONDocument}).\n *\n * For platform-specific implementations, see {@link NodeIO}, {@link WebIO}, and {@link DenoIO}.\n *\n * @category I/O\n */\nexport abstract class PlatformIO {\n\tprotected _logger = Logger.DEFAULT_INSTANCE;\n\tprivate _extensions = new Set<typeof Extension>();\n\tprivate _dependencies: { [key: string]: unknown } = {};\n\tprivate _vertexLayout = VertexLayout.INTERLEAVED;\n\n\t/** @hidden */\n\tpublic lastReadBytes = 0;\n\n\t/** @hidden */\n\tpublic lastWriteBytes = 0;\n\n\t/** Sets the {@link Logger} used by this I/O instance. Defaults to Logger.DEFAULT_INSTANCE. */\n\tpublic setLogger(logger: Logger): this {\n\t\tthis._logger = logger;\n\t\treturn this;\n\t}\n\n\t/** Registers extensions, enabling I/O class to read and write glTF assets requiring them. */\n\tpublic registerExtensions(extensions: typeof Extension[]): this {\n\t\tfor (const extension of extensions) {\n\t\t\tthis._extensions.add(extension);\n\t\t\textension.register();\n\t\t}\n\t\treturn this;\n\t}\n\n\t/** Registers dependencies used (e.g. by extensions) in the I/O process. */\n\tpublic registerDependencies(dependencies: { [key: string]: unknown }): this {\n\t\tObject.assign(this._dependencies, dependencies);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the vertex layout method used by this I/O instance. Defaults to\n\t * VertexLayout.INTERLEAVED.\n\t */\n\tpublic setVertexLayout(layout: VertexLayout): this {\n\t\tthis._vertexLayout = layout;\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Abstract.\n\t */\n\n\tprotected abstract readURI(uri: string, type: 'view'): Promise<Uint8Array>;\n\tprotected abstract readURI(uri: string, type: 'text'): Promise<string>;\n\tprotected abstract readURI(uri: string, type: 'view' | 'text'): Promise<Uint8Array | string>;\n\n\tprotected abstract resolve(base: string, path: string): string;\n\tprotected abstract dirname(uri: string): string;\n\n\t/**********************************************************************************************\n\t * Public Read API.\n\t */\n\n\t/** Reads a {@link Document} from the given URI. */\n\tpublic async read(uri: string): Promise<Document> {\n\t\treturn await this.readJSON(await this.readAsJSON(uri));\n\t}\n\n\t/** Loads a URI and returns a {@link JSONDocument} struct, without parsing. */\n\tpublic async readAsJSON(uri: string): Promise<JSONDocument> {\n\t\tconst isGLB = uri.match(/^data:application\\/octet-stream;/) || FileUtils.extension(uri) === 'glb';\n\t\treturn isGLB ? this._readGLB(uri) : this._readGLTF(uri);\n\t}\n\n\t/** Converts glTF-formatted JSON and a resource map to a {@link Document}. */\n\tpublic async readJSON(jsonDoc: JSONDocument): Promise<Document> {\n\t\tjsonDoc = this._copyJSON(jsonDoc);\n\t\tthis._readResourcesInternal(jsonDoc);\n\t\treturn GLTFReader.read(jsonDoc, {\n\t\t\textensions: Array.from(this._extensions),\n\t\t\tdependencies: this._dependencies,\n\t\t\tlogger: this._logger,\n\t\t});\n\t}\n\n\t/** Converts a GLB-formatted Uint8Array to a {@link JSONDocument}. */\n\tpublic async binaryToJSON(glb: Uint8Array): Promise<JSONDocument> {\n\t\tconst jsonDoc = this._binaryToJSON(BufferUtils.assertView(glb));\n\t\tthis._readResourcesInternal(jsonDoc);\n\t\tconst json = jsonDoc.json;\n\n\t\t// Check for external references, which can't be resolved by this method.\n\t\tif (json.buffers && json.buffers.some((bufferDef) => isExternalBuffer(jsonDoc, bufferDef))) {\n\t\t\tthrow new Error('Cannot resolve external buffers with binaryToJSON().');\n\t\t} else if (json.images && json.images.some((imageDef) => isExternalImage(jsonDoc, imageDef))) {\n\t\t\tthrow new Error('Cannot resolve external images with binaryToJSON().');\n\t\t}\n\n\t\treturn jsonDoc;\n\t}\n\n\t/** Converts a GLB-formatted Uint8Array to a {@link Document}. */\n\tpublic async readBinary(glb: Uint8Array): Promise<Document> {\n\t\treturn this.readJSON(await this.binaryToJSON(BufferUtils.assertView(glb)));\n\t}\n\n\t/**********************************************************************************************\n\t * Public Write API.\n\t */\n\n\t/** Converts a {@link Document} to glTF-formatted JSON and a resource map. */\n\tpublic async writeJSON(doc: Document, _options: PublicWriterOptions = {}): Promise<JSONDocument> {\n\t\tif (_options.format === Format.GLB && doc.getRoot().listBuffers().length > 1) {\n\t\t\tthrow new Error('GLB must have 0–1 buffers.');\n\t\t}\n\t\treturn GLTFWriter.write(doc, {\n\t\t\tformat: _options.format || Format.GLTF,\n\t\t\tbasename: _options.basename || '',\n\t\t\tlogger: this._logger,\n\t\t\tvertexLayout: this._vertexLayout,\n\t\t\tdependencies: { ...this._dependencies },\n\t\t\textensions: Array.from(this._extensions),\n\t\t} as Required<WriterOptions>);\n\t}\n\n\t/** Converts a {@link Document} to a GLB-formatted Uint8Array. */\n\tpublic async writeBinary(doc: Document): Promise<Uint8Array> {\n\t\tconst { json, resources } = await this.writeJSON(doc, { format: Format.GLB });\n\n\t\tconst header = new Uint32Array([0x46546c67, 2, 12]);\n\n\t\tconst jsonText = JSON.stringify(json);\n\t\tconst jsonChunkData = BufferUtils.pad(BufferUtils.encodeText(jsonText), 0x20);\n\t\tconst jsonChunkHeader = BufferUtils.toView(new Uint32Array([jsonChunkData.byteLength, 0x4e4f534a]));\n\t\tconst jsonChunk = BufferUtils.concat([jsonChunkHeader, jsonChunkData]);\n\t\theader[header.length - 1] += jsonChunk.byteLength;\n\n\t\tconst binBuffer = Object.values(resources)[0];\n\t\tif (!binBuffer || !binBuffer.byteLength) {\n\t\t\treturn BufferUtils.concat([BufferUtils.toView(header), jsonChunk]);\n\t\t}\n\n\t\tconst binChunkData = BufferUtils.pad(binBuffer, 0x00);\n\t\tconst binChunkHeader = BufferUtils.toView(new Uint32Array([binChunkData.byteLength, 0x004e4942]));\n\t\tconst binChunk = BufferUtils.concat([binChunkHeader, binChunkData]);\n\t\theader[header.length - 1] += binChunk.byteLength;\n\n\t\treturn BufferUtils.concat([BufferUtils.toView(header), jsonChunk, binChunk]);\n\t}\n\n\t/**********************************************************************************************\n\t * Internal.\n\t */\n\n\tprivate async _readGLTF(uri: string): Promise<JSONDocument> {\n\t\tthis.lastReadBytes = 0;\n\t\tconst jsonContent = await this.readURI(uri, 'text');\n\t\tthis.lastReadBytes += jsonContent.length;\n\t\tconst jsonDoc: JSONDocument = { json: JSON.parse(jsonContent), resources: {} };\n\t\t// Read external resources first, before Data URIs are replaced.\n\t\tawait this._readResourcesExternal(jsonDoc, this.dirname(uri));\n\t\tthis._readResourcesInternal(jsonDoc);\n\t\treturn jsonDoc;\n\t}\n\n\tprivate async _readGLB(uri: string): Promise<JSONDocument> {\n\t\tconst view = await this.readURI(uri, 'view');\n\t\tthis.lastReadBytes = view.byteLength;\n\t\tconst jsonDoc = this._binaryToJSON(view);\n\t\t// Read external resources first, before Data URIs are replaced.\n\t\tawait this._readResourcesExternal(jsonDoc, this.dirname(uri));\n\t\tthis._readResourcesInternal(jsonDoc);\n\t\treturn jsonDoc;\n\t}\n\n\tprivate async _readResourcesExternal(jsonDoc: JSONDocument, base: string): Promise<void> {\n\t\tconst images = jsonDoc.json.images || [];\n\t\tconst buffers = jsonDoc.json.buffers || [];\n\t\tconst pendingResources: Array<Promise<void>> = [...images, ...buffers].map(\n\t\t\tasync (resource: GLTF.IBuffer | GLTF.IImage): Promise<void> => {\n\t\t\t\tconst uri = resource.uri;\n\t\t\t\tif (!uri || uri.match(/data:/)) return Promise.resolve();\n\n\t\t\t\tjsonDoc.resources[uri] = await this.readURI(this.resolve(base, uri), 'view');\n\t\t\t\tthis.lastReadBytes += jsonDoc.resources[uri].byteLength;\n\t\t\t}\n\t\t);\n\t\tawait Promise.all(pendingResources);\n\t}\n\n\tprivate _readResourcesInternal(jsonDoc: JSONDocument): void {\n\t\t// NOTICE: This method may be called more than once during the loading\n\t\t// process (e.g. WebIO.read) and should handle that safely.\n\n\t\tfunction resolveResource(resource: GLTF.IBuffer | GLTF.IImage) {\n\t\t\tif (!resource.uri) return;\n\n\t\t\tif (resource.uri in jsonDoc.resources) {\n\t\t\t\tBufferUtils.assertView(jsonDoc.resources[resource.uri]);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (resource.uri.match(/data:/)) {\n\t\t\t\t// Rewrite Data URIs to something short and unique.\n\t\t\t\tconst resourceUUID = `__${uuid()}.${FileUtils.extension(resource.uri)}`;\n\t\t\t\tjsonDoc.resources[resourceUUID] = BufferUtils.createBufferFromDataURI(resource.uri);\n\t\t\t\tresource.uri = resourceUUID;\n\t\t\t}\n\t\t}\n\n\t\t// Unpack images.\n\t\tconst images = jsonDoc.json.images || [];\n\t\timages.forEach((image: GLTF.IImage) => {\n\t\t\tif (image.bufferView === undefined && image.uri === undefined) {\n\t\t\t\tthrow new Error('Missing resource URI or buffer view.');\n\t\t\t}\n\n\t\t\tresolveResource(image);\n\t\t});\n\n\t\t// Unpack buffers.\n\t\tconst buffers = jsonDoc.json.buffers || [];\n\t\tbuffers.forEach(resolveResource);\n\t}\n\n\t/**\n\t * Creates a shallow copy of glTF-formatted {@link JSONDocument}.\n\t *\n\t * Images, Buffers, and Resources objects are deep copies so that PlatformIO can safely\n\t * modify them during the parsing process. Other properties are shallow copies, and buffers\n\t * are passed by reference.\n\t */\n\tprivate _copyJSON(jsonDoc: JSONDocument): JSONDocument {\n\t\tconst { images, buffers } = jsonDoc.json;\n\n\t\tjsonDoc = { json: { ...jsonDoc.json }, resources: { ...jsonDoc.resources } };\n\n\t\tif (images) {\n\t\t\tjsonDoc.json.images = images.map((image) => ({ ...image }));\n\t\t}\n\t\tif (buffers) {\n\t\t\tjsonDoc.json.buffers = buffers.map((buffer) => ({ ...buffer }));\n\t\t}\n\n\t\treturn jsonDoc;\n\t}\n\n\t/** Internal version of binaryToJSON; does not warn about external resources. */\n\tprivate _binaryToJSON(glb: Uint8Array): JSONDocument {\n\t\t// Decode and verify GLB header.\n\t\tconst header = new Uint32Array(glb.buffer, glb.byteOffset, 3);\n\t\tif (header[0] !== 0x46546c67) {\n\t\t\tthrow new Error('Invalid glTF asset.');\n\t\t} else if (header[1] !== 2) {\n\t\t\tthrow new Error(`Unsupported glTF binary version, \"${header[1]}\".`);\n\t\t}\n\n\t\t// Decode JSON chunk.\n\n\t\tconst jsonChunkHeader = new Uint32Array(glb.buffer, glb.byteOffset + 12, 2);\n\t\tif (jsonChunkHeader[1] !== ChunkType.JSON) {\n\t\t\tthrow new Error('Missing required GLB JSON chunk.');\n\t\t}\n\n\t\tconst jsonByteOffset = 20;\n\t\tconst jsonByteLength = jsonChunkHeader[0];\n\t\tconst jsonText = BufferUtils.decodeText(BufferUtils.toView(glb, jsonByteOffset, jsonByteLength));\n\t\tconst json = JSON.parse(jsonText) as GLTF.IGLTF;\n\n\t\t// Decode BIN chunk.\n\n\t\tconst binByteOffset = jsonByteOffset + jsonByteLength;\n\t\tif (glb.byteLength <= binByteOffset) {\n\t\t\treturn { json, resources: {} };\n\t\t}\n\n\t\tconst binChunkHeader = new Uint32Array(glb.buffer, glb.byteOffset + binByteOffset, 2);\n\t\tif (binChunkHeader[1] !== ChunkType.BIN) {\n\t\t\tthrow new Error('Expected GLB BIN in second chunk.');\n\t\t}\n\n\t\tconst binByteLength = binChunkHeader[0];\n\t\tconst binBuffer = BufferUtils.toView(glb, binByteOffset + 8, binByteLength);\n\n\t\treturn { json, resources: { [GLB_BUFFER]: binBuffer } };\n\t}\n}\n\nfunction isExternalBuffer(jsonDocument: JSONDocument, bufferDef: GLTF.IBuffer): boolean {\n\treturn bufferDef.uri !== undefined && !(bufferDef.uri in jsonDocument.resources);\n}\n\nfunction isExternalImage(jsonDocument: JSONDocument, imageDef: GLTF.IImage): boolean {\n\treturn imageDef.uri !== undefined && !(imageDef.uri in jsonDocument.resources) && imageDef.bufferView === undefined;\n}\n","import { Format } from '../constants';\nimport { Document } from '../document';\nimport { FileUtils } from '../utils/';\nimport { PlatformIO } from './platform-io';\nimport { HTTPUtils } from '../utils';\n\n/**\n * # NodeIO\n *\n * *I/O service for Node.js.*\n *\n * The most common use of the I/O service is to read/write a {@link Document} with a given path.\n * Methods are also available for converting in-memory representations of raw glTF files, both\n * binary (*Uint8Array*) and JSON ({@link JSONDocument}).\n *\n * Usage:\n *\n * ```typescript\n * const { NodeIO } = require('@gltf-transform/core');\n *\n * const io = new NodeIO();\n *\n * // Read.\n * let document;\n * document = await io.read('model.glb'); // → Document\n * document = await io.readBinary(glb);   // Uint8Array → Document\n *\n * // Write.\n * await io.write('model.glb', document);      // → void\n * const glb = await io.writeBinary(document); // Document → Uint8Array\n * ```\n *\n * By default, NodeIO can only read/write paths on disk. To enable HTTP requests, provide a Fetch\n * API implementation (such as [`node-fetch`](https://www.npmjs.com/package/node-fetch)) and enable\n * {@link setAllowHTTP}. HTTP requests may optionally be configured with\n * [RequestInit](https://developer.mozilla.org/en-US/docs/Web/API/fetch#parameters) parameters.\n *\n * ```typescript\n * import fetch from 'node-fetch';\n *\n * const io = new NodeIO(fetch, {headers: {...}}).setAllowHTTP(true);\n *\n * const document = await io.read('https://example.com/path/to/model.glb');\n * ```\n *\n * @category I/O\n */\nexport class NodeIO extends PlatformIO {\n\tprivate readonly _fs;\n\tprivate readonly _path;\n\tprivate readonly _fetch: typeof fetch | null;\n\tprivate readonly _fetchConfig: RequestInit;\n\n\tprivate _fetchEnabled = false;\n\n\t/**\n\t * Constructs a new NodeIO service. Instances are reusable. By default, only NodeIO can only\n\t * read/write paths on disk. To enable HTTP requests, provide a Fetch API implementation and\n\t * enable {@link setAllowHTTP}.\n\t *\n\t * @param fetch Implementation of Fetch API.\n\t * @param fetchConfig Configuration object for Fetch API.\n\t */\n\tconstructor(_fetch: unknown = null, _fetchConfig = HTTPUtils.DEFAULT_INIT) {\n\t\tsuper();\n\t\t// Excluded from browser builds with 'package.browser' field.\n\t\tthis._fs = require('fs').promises;\n\t\tthis._path = require('path');\n\t\tthis._fetch = _fetch as typeof fetch | null;\n\t\tthis._fetchConfig = _fetchConfig;\n\t}\n\n\tpublic setAllowHTTP(allow: boolean): this {\n\t\tif (allow && !this._fetch) {\n\t\t\tthrow new Error('NodeIO requires a Fetch API implementation for HTTP requests.');\n\t\t}\n\t\tthis._fetchEnabled = allow;\n\t\treturn this;\n\t}\n\n\tprotected async readURI(uri: string, type: 'view'): Promise<Uint8Array>;\n\tprotected async readURI(uri: string, type: 'text'): Promise<string>;\n\tprotected async readURI(uri: string, type: 'view' | 'text'): Promise<Uint8Array | string> {\n\t\tif (HTTPUtils.isAbsoluteURL(uri)) {\n\t\t\tif (!this._fetchEnabled || !this._fetch) {\n\t\t\t\tthrow new Error('Network request blocked. Allow HTTP requests explicitly, if needed.');\n\t\t\t}\n\n\t\t\tconst response = await this._fetch(uri, this._fetchConfig);\n\t\t\tswitch (type) {\n\t\t\t\tcase 'view':\n\t\t\t\t\treturn new Uint8Array(await response.arrayBuffer());\n\t\t\t\tcase 'text':\n\t\t\t\t\treturn response.text();\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (type) {\n\t\t\t\tcase 'view':\n\t\t\t\t\treturn this._fs.readFile(uri);\n\t\t\t\tcase 'text':\n\t\t\t\t\treturn this._fs.readFile(uri, 'utf8');\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected resolve(base: string, path: string): string {\n\t\tif (HTTPUtils.isAbsoluteURL(base) || HTTPUtils.isAbsoluteURL(path)) {\n\t\t\treturn HTTPUtils.resolve(base, path);\n\t\t}\n\t\treturn this._path.resolve(base, path);\n\t}\n\n\tprotected dirname(uri: string): string {\n\t\tif (HTTPUtils.isAbsoluteURL(uri)) {\n\t\t\treturn HTTPUtils.dirname(uri);\n\t\t}\n\t\treturn this._path.dirname(uri);\n\t}\n\n\t/**********************************************************************************************\n\t * Public.\n\t */\n\n\t/** Writes a {@link Document} instance to a local path. */\n\tpublic async write(uri: string, doc: Document): Promise<void> {\n\t\tconst isGLB = !!uri.match(/\\.glb$/);\n\t\tawait (isGLB ? this._writeGLB(uri, doc) : this._writeGLTF(uri, doc));\n\t}\n\n\t/**********************************************************************************************\n\t * Private.\n\t */\n\n\t/** @internal */\n\tprivate async _writeGLTF(uri: string, doc: Document): Promise<void> {\n\t\tthis.lastWriteBytes = 0;\n\t\tconst { json, resources } = await this.writeJSON(doc, {\n\t\t\tformat: Format.GLTF,\n\t\t\tbasename: FileUtils.basename(uri),\n\t\t});\n\t\tconst { _fs: fs, _path: path } = this;\n\t\tconst dir = path.dirname(uri);\n\t\tconst jsonContent = JSON.stringify(json, null, 2);\n\t\tthis.lastWriteBytes += jsonContent.length;\n\t\tawait fs.writeFile(uri, jsonContent);\n\t\tconst pending = Object.keys(resources).map(async (resourceURI) => {\n\t\t\tif (HTTPUtils.isAbsoluteURL(resourceURI)) {\n\t\t\t\tif (FileUtils.extension(resourceURI) === 'bin') {\n\t\t\t\t\tthrow new Error(`Cannot write buffer to path \"${resourceURI}\".`);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst resource = Buffer.from(resources[resourceURI]);\n\t\t\tawait fs.writeFile(path.join(dir, resourceURI), resource);\n\t\t\tthis.lastWriteBytes += resource.byteLength;\n\t\t});\n\t\tawait Promise.all(pending);\n\t}\n\n\t/** @internal */\n\tprivate async _writeGLB(uri: string, doc: Document): Promise<void> {\n\t\tconst buffer = Buffer.from(await this.writeBinary(doc));\n\t\tawait this._fs.writeFile(uri, buffer);\n\t\tthis.lastWriteBytes = buffer.byteLength;\n\t}\n}\n","import { PlatformIO } from './platform-io';\n\ninterface Path {\n\tresolve(base: string, path: string): string;\n\tdirname(uri: string): string;\n}\n\n/**\n * # DenoIO\n *\n * *I/O service for [Deno](https://deno.land/).*\n *\n * The most common use of the I/O service is to read/write a {@link Document} with a given path.\n * Methods are also available for converting in-memory representations of raw glTF files, both\n * binary (*Uint8Array*) and JSON ({@link JSONDocument}).\n *\n * _*NOTICE:* Support for the Deno environment is currently experimental. See\n * [glTF-Transform#457](https://github.com/donmccurdy/glTF-Transform/issues/457)._\n *\n * Usage:\n *\n * ```typescript\n * import { DenoIO } from 'https://esm.sh/@gltf-transform/core';\n * import * as path from 'https://deno.land/std/path/mod.ts';\n *\n * const io = new DenoIO(path);\n *\n * // Read.\n * let document;\n * document = io.read('model.glb');  // → Document\n * document = io.readBinary(glb);    // Uint8Array → Document\n *\n * // Write.\n * const glb = io.writeBinary(document);  // Document → Uint8Array\n * ```\n *\n * @category I/O\n */\nexport class DenoIO extends PlatformIO {\n\tprivate _path: Path;\n\n\tconstructor(path: unknown) {\n\t\tsuper();\n\t\tthis._path = path as Path;\n\t}\n\n\tprotected async readURI(uri: string, type: 'view'): Promise<Uint8Array>;\n\tprotected async readURI(uri: string, type: 'text'): Promise<string>;\n\tprotected async readURI(uri: string, type: 'view' | 'text'): Promise<Uint8Array | string> {\n\t\t// TODO(cleanup): The @ts-ignore rules below are necessary for typedoc, but not for normal\n\t\t// compilation with microbundle. Clean this up when possible.\n\t\tswitch (type) {\n\t\t\tcase 'view':\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t\t\t\t// @ts-ignore\n\t\t\t\treturn Deno.readFile(uri);\n\t\t\tcase 'text':\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t\t\t\t// @ts-ignore\n\t\t\t\treturn Deno.readTextFile(uri);\n\t\t}\n\t}\n\n\tprotected resolve(base: string, path: string): string {\n\t\treturn this._path.resolve(base, path);\n\t}\n\n\tprotected dirname(uri: string): string {\n\t\treturn this._path.dirname(uri);\n\t}\n}\n","import { PlatformIO } from './platform-io';\nimport { HTTPUtils } from '../utils';\n\n/**\n * # WebIO\n *\n * *I/O service for Web.*\n *\n * The most common use of the I/O service is to read/write a {@link Document} with a given path.\n * Methods are also available for converting in-memory representations of raw glTF files, both\n * binary (*Uint8Array*) and JSON ({@link JSONDocument}).\n *\n * Usage:\n *\n * ```typescript\n * import { WebIO } from '@gltf-transform/core';\n *\n * const io = new WebIO({credentials: 'include'});\n *\n * // Read.\n * let document;\n * document = await io.read('model.glb');  // → Document\n * document = await io.readBinary(glb);    // Uint8Array → Document\n *\n * // Write.\n * const glb = await io.writeBinary(document); // Document → Uint8Array\n * ```\n *\n * @category I/O\n */\nexport class WebIO extends PlatformIO {\n\tprivate readonly _fetchConfig: RequestInit;\n\n\t/**\n\t * Constructs a new WebIO service. Instances are reusable.\n\t * @param fetchConfig Configuration object for Fetch API.\n\t */\n\tconstructor(fetchConfig = HTTPUtils.DEFAULT_INIT) {\n\t\tsuper();\n\t\tthis._fetchConfig = fetchConfig;\n\t}\n\n\tprotected async readURI(uri: string, type: 'view'): Promise<Uint8Array>;\n\tprotected async readURI(uri: string, type: 'text'): Promise<string>;\n\tprotected async readURI(uri: string, type: 'view' | 'text'): Promise<Uint8Array | string> {\n\t\tconst response = await fetch(uri, this._fetchConfig);\n\t\tswitch (type) {\n\t\t\tcase 'view':\n\t\t\t\treturn new Uint8Array(await response.arrayBuffer());\n\t\t\tcase 'text':\n\t\t\t\treturn response.text();\n\t\t}\n\t}\n\n\tprotected resolve(base: string, path: string): string {\n\t\treturn HTTPUtils.resolve(base, path);\n\t}\n\n\tprotected dirname(uri: string): string {\n\t\treturn HTTPUtils.dirname(uri);\n\t}\n}\n"],"names":["VERSION","GLB_BUFFER","PropertyType","VertexLayout","BufferViewUsage","TextureChannel","Format","bounds","node","resultBounds","min","Infinity","max","parents","propertyType","NODE","listChildren","parent","traverse","mesh","getMesh","meshBounds","getMeshBounds","getWorldMatrix","expandBounds","worldMatrix","prim","listPrimitives","position","getAttribute","localPos","worldPos","i","getCount","getElement","transformMat4","point","target","Math","BufferUtils","[object Object]","dataURI","Buffer","byteString","atob","split","ia","Uint8Array","length","charCodeAt","data","isBase64","indexOf","from","text","TextEncoder","encode","array","TextDecoder","decode","toString","arrays","totalByteLength","byteLength","result","byteOffset","set","srcArray","paddingByte","paddedLength","this","padNumber","dstArray","v","ceil","a","b","buffer","view","ArrayBuffer","isView","Error","ColorUtils","hex","floor","_target","convertSRGBToLinear","factor","r","g","convertLinearToSRGB","source","_source","pow","FileUtils","path","fileName","URL","pathname","pop","substring","lastIndexOf","PNGImageUtils","match","getSize","DataView","decodeText","slice","PNG_FRIED_CHUNK_NAME","getUint32","getChannels","_buffer","ImageUtils","mimeType","impl","impls","getGPUByteLength","uncompressedBytes","resolution","extension","validateJPEGBuffer","TypeError","getUint8","isObject","o","Object","prototype","call","isPlainObject","ctor","constructor","undefined","prot","hasOwnProperty","image/jpeg","next","getUint16","image/png","Logger","verbosity","debug","Verbosity","DEBUG","console","info","INFO","warn","WARN","error","ERROR","SILENT","DEFAULT_INSTANCE","MathUtils","abs","c","componentType","f","round","srcMat","dstTranslation","dstRotation","dstScale","sx","sy","sz","determinant","_m1","invSX","invSY","invSZ","getRotation","srcTranslation","srcRotation","srcScale","dstMat","te","x","y","z","w","x2","y2","z2","xx","xy","xz","yy","yz","zz","wx","wy","wz","equalsRef","refA","refB","getChild","equals","equalsRefList","refListA","refListB","equalsRefMap","refMapA","refMapB","keysA","keys","keysB","key","equalsArray","equalsObject","_a","_b","numKeysA","numKeysB","valueA","valueB","isArray","value","Array","ALPHABET","previousIDs","Set","generateOne","rtn","charAt","random","uuid","retries","id","has","add","HTTPUtils","index","base","isRelativePath","stack","parts","push","join","PROTOCOL_REGEXP","test","DEFAULT_INIT","COPY_IDENTITY","t","Property","GraphNode","graph","name","super","$attributes","init","dispatchEvent","type","getDefaults","assign","extras","getName","get","setName","getExtras","setExtras","clone","PropertyClass","copy","other","resolve","GraphEdge","$immutableKeys","dispose","ref","values","subkey","thisValue","otherValue","setRef","getAttributes","addRef","setRefMap","JSON","parse","stringify","isRef","isRefList","isRefMap","detach","disconnectParents","n","listParents","ExtensibleProperty","extensions","getExtension","getRefMap","setExtension","extensionProperty","_validateParent","listExtensions","listRefMapValues","Accessor","_in","identity","_out","ACCESSOR","Type","SCALAR","ComponentType","FLOAT","normalized","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","BYTE","UNSIGNED_BYTE","SHORT","UNSIGNED_SHORT","UNSIGNED_INT","getMinNormalized","elementSize","getElementSize","getMin","j","count","Number","isFinite","getMaxNormalized","getMax","getType","setType","getComponentSize","BYTES_PER_ELEMENT","getComponentType","getNormalized","setNormalized","denormalize","normalize","getScalar","setScalar","setElement","getBuffer","getRef","setBuffer","getArray","setArray","Float32Array","Uint32Array","Uint16Array","Int16Array","Int8Array","arrayToComponentType","getByteLength","Animation","ANIMATION","channels","samplers","addChannel","channel","removeChannel","removeRef","listChannels","listRefs","addSampler","sampler","removeSampler","listSamplers","AnimationChannel","ANIMATION_CHANNEL","targetPath","targetNode","getTargetPath","setTargetPath","getTargetNode","setTargetNode","getSampler","setSampler","TargetPath","TRANSLATION","ROTATION","SCALE","WEIGHTS","AnimationSampler","ANIMATION_SAMPLER","getDefaultAttributes","interpolation","Interpolation","LINEAR","input","output","getInterpolation","setInterpolation","getInput","setInput","usage","OTHER","getOutput","setOutput","STEP","CUBICSPLINE","BUFFER","uri","getURI","setURI","Camera","CAMERA","PERSPECTIVE","znear","zfar","aspectRatio","yfov","PI","xmag","ymag","getZNear","setZNear","getZFar","setZFar","getAspectRatio","setAspectRatio","getYFov","setYFov","getXMag","setXMag","getYMag","setYMag","ORTHOGRAPHIC","ExtensionProperty","parentTypes","includes","EXTENSION_NAME","TextureInfo","TEXTURE_INFO","texCoord","magFilter","minFilter","wrapS","WrapMode","REPEAT","wrapT","getTexCoord","setTexCoord","getMagFilter","setMagFilter","getMinFilter","setMinFilter","getWrapS","setWrapS","getWrapT","setWrapT","CLAMP_TO_EDGE","MIRRORED_REPEAT","MagFilter","NEAREST","MinFilter","NEAREST_MIPMAP_NEAREST","LINEAR_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_LINEAR","R","G","B","A","Material","MATERIAL","alphaMode","AlphaMode","OPAQUE","alphaCutoff","doubleSided","baseColorFactor","baseColorTexture","baseColorTextureInfo","emissiveFactor","emissiveTexture","emissiveTextureInfo","normalScale","normalTexture","normalTextureInfo","occlusionStrength","occlusionTexture","occlusionTextureInfo","roughnessFactor","metallicFactor","metallicRoughnessTexture","metallicRoughnessTextureInfo","getDoubleSided","setDoubleSided","getAlpha","setAlpha","alpha","getAlphaMode","setAlphaMode","getAlphaCutoff","setAlphaCutoff","getBaseColorFactor","setBaseColorFactor","getBaseColorHex","factorToHex","setBaseColorHex","hexToFactor","getBaseColorTexture","getBaseColorTextureInfo","setBaseColorTexture","texture","getEmissiveFactor","setEmissiveFactor","getEmissiveHex","setEmissiveHex","getEmissiveTexture","getEmissiveTextureInfo","setEmissiveTexture","getNormalScale","setNormalScale","scale","getNormalTexture","getNormalTextureInfo","setNormalTexture","getOcclusionStrength","setOcclusionStrength","strength","getOcclusionTexture","getOcclusionTextureInfo","setOcclusionTexture","getRoughnessFactor","setRoughnessFactor","getMetallicFactor","setMetallicFactor","getMetallicRoughnessTexture","getMetallicRoughnessTextureInfo","setMetallicRoughnessTexture","MASK","BLEND","Mesh","MESH","weights","primitives","addPrimitive","primitive","removePrimitive","getWeights","setWeights","Node","_parent","translation","rotation","camera","skin","children","getTranslation","getScale","setTranslation","setRotation","setScale","getMatrix","compose","setMatrix","matrix","decompose","getWorldTranslation","getWorldRotation","getWorldScale","s","ancestors","ancestor","multiply","addChild","child","removeChild","childrenRefs","addEventListener","getParent","setMesh","getCamera","setCamera","getSkin","setSkin","fn","Primitive","PRIMITIVE","mode","Mode","TRIANGLES","material","indices","attributes","targets","getIndices","setIndices","ELEMENT_ARRAY_BUFFER","semantic","setAttribute","accessor","ARRAY_BUFFER","listAttributes","listSemantics","listRefMapKeys","getMaterial","setMaterial","getMode","setMode","listTargets","addTarget","removeTarget","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLE_STRIP","TRIANGLE_FAN","PrimitiveTarget","PRIMITIVE_TARGET","Scene","SCENE","Skin","SKIN","skeleton","inverseBindMatrices","joints","getSkeleton","setSkeleton","getInverseBindMatrices","setInverseBindMatrices","INVERSE_BIND_MATRICES","addJoint","joint","removeJoint","listJoints","Texture","TEXTURE","image","getMimeType","extensionToMimeType","setMimeType","getImage","setImage","assertView","Root","ROOT","asset","generator","version","defaultScene","accessors","animations","buffers","cameras","materials","meshes","nodes","scenes","skins","textures","_extensions","event","_addChildOfRoot","setDefaultScene","getDefaultScene","extensionName","otherExtension","getAsset","listExtensionsUsed","listExtensionsRequired","filter","isRequired","_enableExtension","_disableExtension","delete","listScenes","listNodes","listCameras","listSkins","listMeshes","listMaterials","listTextures","listAnimations","listAccessors","listBuffers","Document","_graph","Graph","_root","_logger","getRoot","getGraph","getLogger","setLogger","logger","merge","thisExtension","createExtension","setRequired","visited","propertyMap","Map","edge","listEdges","thisProp","otherProp","p","resolved","transforms","map","transform","find","ext","createScene","createNode","createCamera","createSkin","createMesh","createPrimitive","createPrimitiveTarget","createMaterial","createTexture","createAnimation","createAnimationChannel","createAnimationSampler","createAccessor","createBuffer","Extension","document","prereadTypes","prewriteTypes","readDependencies","writeDependencies","required","properties","_listener","_event","_addExtensionProperty","_removeExtensionProperty","removeEventListener","property","install","dependency","preread","_readerContext","_propertyType","prewrite","_writerContext","ReaderContext","jsonDoc","bufferViews","bufferViewBuffers","textureInfos","setTextureInfo","textureInfo","textureInfoDef","textureDef","json","samplerDef","ComponentTypeToTypedArray","5120","5121","5122","5123","5125","5126","DEFAULT_OPTIONS","dependencies","getAccessorArray","accessorDef","context","bufferView","bufferViewDef","TypedArray","componentSize","byteStride","accessorByteOffset","getFloat32","getInt16","getInt8","getInterleavedArray","BufferViewTarget","WriterContext","_doc","options","accessorIndexMap","animationIndexMap","bufferIndexMap","cameraIndexMap","skinIndexMap","materialIndexMap","meshIndexMap","nodeIndexMap","imageIndexMap","textureDefIndexMap","textureInfoDefMap","samplerDefIndexMap","sceneIndexMap","imageBufferViews","otherBufferViews","otherBufferViewsIndexMap","extensionData","bufferURIGenerator","imageURIGenerator","_accessorUsageMap","accessorUsageGroupedByParent","accessorParents","root","numBuffers","numImages","UniqueURIGenerator","basename","createTextureInfoDef","samplerKey","textureKey","createPropertyDef","def","createAccessorDef","listParentEdges","some","fround","createImageData","imageDef","format","GLB","mimeTypeToExtension","createURI","resources","getAccessorUsage","cachedUsage","addAccessorToUsageGroup","prevUsage","listAccessorUsageGroups","entries","USAGE_TO_TARGET","multiple","counter","object","ChunkType","PlatformIO","_dependencies","_vertexLayout","INTERLEAVED","lastReadBytes","lastWriteBytes","registerExtensions","register","registerDependencies","setVertexLayout","layout","readJSON","readAsJSON","_readGLB","_readGLTF","_copyJSON","_readResourcesInternal","_options","doc","validate","assetDef","copyright","extensionsUsed","extensionsRequired","bufferDefs","forEach","bufferDef","toView","sparse","sparseDef","indicesDef","valuesDef","getSparseArray","imageDefs","images","textureDefs","imageData","materialDef","pbrDef","pbrMetallicRoughness","meshDefs","meshDef","primitiveDef","targetNames","targetDef","targetIndex","targetName","accessorIndex","cameraDef","perspectiveDef","perspective","orthoDef","orthographic","nodeDefs","nodeDef","skinDef","nodeIndex","childIndex","animationDef","animation","channelDef","sceneDefs","sceneDef","scene","read","glb","_binaryToJSON","jsonDocument","isExternalBuffer","isExternalImage","binaryToJSON","extensionsRegistered","concatAccessors","bufferIndex","bufferByteOffset","bufferViewTarget","accessorArray","pad","concat","interleaveAccessors","vertexCount","vertexByteOffset","viewByteOffset","setFloat32","setInt8","setInt16","setUint8","setUint16","setUint32","accessorRefs","uses","textureIndex","groupByParent","accessorEdges","parentAccessors","size","bufferAccessors","bufferAccessorsSet","bufferByteLength","usageGroups","vertexLayout","imagePadding","eq","samplerIndexMap","samplerIndex","write","unused","clean","GLTF","writeJSON","header","jsonText","jsonChunkData","encodeText","jsonChunkHeader","jsonChunk","binBuffer","binChunkData","binChunkHeader","binChunk","jsonContent","readURI","_readResourcesExternal","dirname","pendingResources","async","resource","Promise","_this","all","resolveResource","resourceUUID","createBufferFromDataURI","jsonByteLength","binByteOffset","BIN","@glb.bin","NodeIO","_fetch","_fetchConfig","_fs","_path","_fetchEnabled","require","promises","setAllowHTTP","allow","isAbsoluteURL","response","arrayBuffer","readFile","isGLB","_writeGLB","_writeGLTF","fs","dir","writeFile","pending","resourceURI","writeBinary","DenoIO","Deno","readTextFile","WebIO","fetchConfig","fetch"],"mappings":"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"}